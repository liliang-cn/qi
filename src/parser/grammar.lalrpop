use crate::parser::ast::*;

grammar;

pub Program: Program = {
    <statements:Statement*> => Program {
        package_name: None,
        imports: vec![],
        statements,
        source_span: Default::default(),
    }
};

Statement: AstNode = {
    VariableDeclaration,
    FunctionDeclaration,
    StructDeclaration,
    ReturnStatement,
    PrintStatement,
    IfStatement,
    WhileStatement,
    ForStatement,
    <e:Expr> ";" => AstNode::表达式语句(ExpressionStatement {
        expression: Box::new(e),
        span: Default::default(),
    }),
};

VariableDeclaration: AstNode = {
    "变量" <name:Identifier> ":" <type_annotation:Type> "=" <value:Expr> ";" => AstNode::变量声明(VariableDeclaration {
        name,
        type_annotation: Some(type_annotation),
        initializer: Some(Box::new(value)),
        is_mutable: true,
        span: Default::default(),
    }),
    "变量" <name:Identifier> "=" <value:Expr> ";" => AstNode::变量声明(VariableDeclaration {
        name,
        type_annotation: None,
        initializer: Some(Box::new(value)),
        is_mutable: true,
        span: Default::default(),
    }),
    "常量" <name:Identifier> ":" <type_annotation:Type> "=" <value:Expr> ";" => AstNode::变量声明(VariableDeclaration {
        name,
        type_annotation: Some(type_annotation),
        initializer: Some(Box::new(value)),
        is_mutable: false,
        span: Default::default(),
    }),
    "常量" <name:Identifier> "=" <value:Expr> ";" => AstNode::变量声明(VariableDeclaration {
        name,
        type_annotation: None,
        initializer: Some(Box::new(value)),
        is_mutable: false,
        span: Default::default(),
    }),
};

FunctionDeclaration: AstNode = {
    // 带接收器的函数(方法) - Go 风格
    "函数" "(" <receiver_name:Identifier> <receiver_type:Identifier> ")" <name:Identifier> "(" ")" ":" <return_type:Type> "{" <body:Statement*> "}" => AstNode::方法声明(MethodDeclaration {
        receiver_name,
        receiver_type,
        is_receiver_mutable: false,
        method_name: name,
        parameters: vec![],
        return_type: Some(return_type),
        body,
        span: Default::default(),
    }),
    "函数" "(" <receiver_name:Identifier> <receiver_type:Identifier> ")" <name:Identifier> "(" ")" "{" <body:Statement*> "}" => AstNode::方法声明(MethodDeclaration {
        receiver_name,
        receiver_type,
        is_receiver_mutable: false,
        method_name: name,
        parameters: vec![],
        return_type: None,
        body,
        span: Default::default(),
    }),
    "函数" "(" <receiver_name:Identifier> <receiver_type:Identifier> ")" <name:Identifier> "(" <params:ParameterList> ")" ":" <return_type:Type> "{" <body:Statement*> "}" => AstNode::方法声明(MethodDeclaration {
        receiver_name,
        receiver_type,
        is_receiver_mutable: false,
        method_name: name,
        parameters: params,
        return_type: Some(return_type),
        body,
        span: Default::default(),
    }),
    "函数" "(" <receiver_name:Identifier> <receiver_type:Identifier> ")" <name:Identifier> "(" <params:ParameterList> ")" "{" <body:Statement*> "}" => AstNode::方法声明(MethodDeclaration {
        receiver_name,
        receiver_type,
        is_receiver_mutable: false,
        method_name: name,
        parameters: params,
        return_type: None,
        body,
        span: Default::default(),
    }),
    // 可变接收器的函数
    "函数" "(" "变量" <receiver_name:Identifier> <receiver_type:Identifier> ")" <name:Identifier> "(" ")" ":" <return_type:Type> "{" <body:Statement*> "}" => AstNode::方法声明(MethodDeclaration {
        receiver_name,
        receiver_type,
        is_receiver_mutable: true,
        method_name: name,
        parameters: vec![],
        return_type: Some(return_type),
        body,
        span: Default::default(),
    }),
    "函数" "(" "变量" <receiver_name:Identifier> <receiver_type:Identifier> ")" <name:Identifier> "(" ")" "{" <body:Statement*> "}" => AstNode::方法声明(MethodDeclaration {
        receiver_name,
        receiver_type,
        is_receiver_mutable: true,
        method_name: name,
        parameters: vec![],
        return_type: None,
        body,
        span: Default::default(),
    }),
    "函数" "(" "变量" <receiver_name:Identifier> <receiver_type:Identifier> ")" <name:Identifier> "(" <params:ParameterList> ")" ":" <return_type:Type> "{" <body:Statement*> "}" => AstNode::方法声明(MethodDeclaration {
        receiver_name,
        receiver_type,
        is_receiver_mutable: true,
        method_name: name,
        parameters: params,
        return_type: Some(return_type),
        body,
        span: Default::default(),
    }),
    "函数" "(" "变量" <receiver_name:Identifier> <receiver_type:Identifier> ")" <name:Identifier> "(" <params:ParameterList> ")" "{" <body:Statement*> "}" => AstNode::方法声明(MethodDeclaration {
        receiver_name,
        receiver_type,
        is_receiver_mutable: true,
        method_name: name,
        parameters: params,
        return_type: None,
        body,
        span: Default::default(),
    }),
    // 普通函数(无接收器)
    "函数" <name:Identifier> "(" ")" ":" <return_type:Type> "{" <body:Statement*> "}" => AstNode::函数声明(FunctionDeclaration {
        name,
        parameters: vec![],
        return_type: Some(return_type),
        body,
        span: Default::default(),
    }),
    "函数" <name:Identifier> "(" ")" "{" <body:Statement*> "}" => AstNode::函数声明(FunctionDeclaration {
        name,
        parameters: vec![],
        return_type: None,
        body,
        span: Default::default(),
    }),
    "函数" <name:Identifier> "(" <params:ParameterList> ")" ":" <return_type:Type> "{" <body:Statement*> "}" => AstNode::函数声明(FunctionDeclaration {
        name,
        parameters: params,
        return_type: Some(return_type),
        body,
        span: Default::default(),
    }),
    "函数" <name:Identifier> "(" <params:ParameterList> ")" "{" <body:Statement*> "}" => AstNode::函数声明(FunctionDeclaration {
        name,
        parameters: params,
        return_type: None,
        body,
        span: Default::default(),
    }),
};

ReturnStatement: AstNode = {
    "返回" <value:Expr> ";" => AstNode::返回语句(ReturnStatement {
        value: Some(Box::new(value)),
        span: Default::default(),
    }),
    "返回" ";" => AstNode::返回语句(ReturnStatement {
        value: None,
        span: Default::default(),
    }),
};

PrintStatement: AstNode = {
    "打印" <value:Expr> ";" => AstNode::打印语句(PrintStatement {
        value: Box::new(value),
        span: Default::default(),
    }),
};

Block: Vec<AstNode> = {
    "{" <statements:Statement*> "}" => statements
};

IfStatement: AstNode = {
    IfWithElse,
    IfWithoutElse,
};

// If statements with else (higher precedence to resolve dangling-else)
IfWithElse: AstNode = {
    "如果" <condition:Expr> <then_branch:Block> "否则" <else_branch:Block> => {
        AstNode::如果语句(IfStatement {
            condition: Box::new(condition),
            then_branch,
            else_branch: Some(Box::new(AstNode::块语句(BlockStatement {
                statements: else_branch,
                span: Default::default(),
            }))),
            span: Default::default(),
        })
    },
    "如果" <condition:Expr> <then_branch:Block> "否则如果" <else_if:IfWithElse> => {
        AstNode::如果语句(IfStatement {
            condition: Box::new(condition),
            then_branch,
            else_branch: Some(Box::new(else_if)),
            span: Default::default(),
        })
    },
};

// If statements without else
IfWithoutElse: AstNode = {
    "如果" <condition:Expr> <then_branch:Block> => {
        AstNode::如果语句(IfStatement {
            condition: Box::new(condition),
            then_branch,
            else_branch: None,
            span: Default::default(),
        })
    },
};

WhileStatement: AstNode = {
    "当" <condition:Expr> <body:Block> => AstNode::当语句(WhileStatement {
        condition: Box::new(condition),
        body,
        span: Default::default(),
    }),
};

ForStatement: AstNode = {
    "对于" <variable:Identifier> "在" <range:Expr> <body:Block> => AstNode::对于语句(ForStatement {
        variable,
        range: Box::new(range),
        body,
        span: Default::default(),
    }),
};

StructDeclaration: AstNode = {
    "结构体" <name:Identifier> "{" <fields:StructFieldList> "}" => AstNode::结构体声明(StructDeclaration {
        name,
        fields,
        methods: vec![],
        span: Default::default(),
    }),
    "结构体" <name:Identifier> "{" "}" => AstNode::结构体声明(StructDeclaration {
        name,
        fields: vec![],
        methods: vec![],
        span: Default::default(),
    }),
};

StructFieldList: Vec<StructField> = {
    <fields:Comma<StructField>> => fields,
};

StructField: StructField = {
    <name:Identifier> ":" <type_annotation:Type> => StructField {
        name,
        type_annotation,
        is_embedded: false,
        span: Default::default(),
    },
};
// Expression hierarchy using tiered approach like Solang
// Each level handles operators of the same precedence
Expr: AstNode = {
    Precedence1,
};

// Level 1: Assignment (lowest precedence, right-associative)
// Only Precedence8 (postfix) expressions can be assigned to (identifiers, field access, array subscript)
Precedence1: AstNode = {
    <left:Precedence8> "=" <right:Precedence1> => {
        // Validate that left is a valid LValue
        match &left {
            AstNode::标识符表达式(_) |
            AstNode::字段访问表达式(_) |
            AstNode::数组访问表达式(_) => {
                AstNode::赋值表达式(AssignmentExpression {
                    target: Box::new(left),
                    value: Box::new(right),
                    span: Default::default(),
                })
            },
            _ => panic!("Invalid assignment target: only identifiers, field access, and array subscript are allowed")
        }
    },
    Precedence2,
};

// Level 2: Logical OR
Precedence2: AstNode = {
    <left:Precedence2> "或" <right:Precedence3> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::或,
        right: Box::new(right),
        span: Default::default(),
    }),
    <left:Precedence2> "||" <right:Precedence3> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::或,
        right: Box::new(right),
        span: Default::default(),
    }),
    Precedence3,
};

// Level 3: Logical AND
Precedence3: AstNode = {
    <left:Precedence3> "与" <right:Precedence4> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::与,
        right: Box::new(right),
        span: Default::default(),
    }),
    <left:Precedence3> "&&" <right:Precedence4> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::与,
        right: Box::new(right),
        span: Default::default(),
    }),
    Precedence4,
};

// Level 4: Comparison operators
Precedence4: AstNode = {
    <left:Precedence5> "==" <right:Precedence5> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::等于,
        right: Box::new(right),
        span: Default::default(),
    }),
    <left:Precedence5> "!=" <right:Precedence5> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::不等于,
        right: Box::new(right),
        span: Default::default(),
    }),
    <left:Precedence5> ">" <right:Precedence5> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::大于,
        right: Box::new(right),
        span: Default::default(),
    }),
    <left:Precedence5> ">=" <right:Precedence5> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::大于等于,
        right: Box::new(right),
        span: Default::default(),
    }),
    <left:Precedence5> "<" <right:Precedence5> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::小于,
        right: Box::new(right),
        span: Default::default(),
    }),
    <left:Precedence5> "<=" <right:Precedence5> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::小于等于,
        right: Box::new(right),
        span: Default::default(),
    }),
    Precedence5,
};

// Level 5: Addition and subtraction
Precedence5: AstNode = {
    <left:Precedence5> "+" <right:Precedence6> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::加,
        right: Box::new(right),
        span: Default::default(),
    }),
    <left:Precedence5> "-" <right:Precedence6> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::减,
        right: Box::new(right),
        span: Default::default(),
    }),
    Precedence6,
};

// Level 6: Multiplication, division, and modulo
Precedence6: AstNode = {
    <left:Precedence6> "*" <right:Precedence7> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::乘,
        right: Box::new(right),
        span: Default::default(),
    }),
    <left:Precedence6> "/" <right:Precedence7> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::除,
        right: Box::new(right),
        span: Default::default(),
    }),
    <left:Precedence6> "%" <right:Precedence7> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::取余,
        right: Box::new(right),
        span: Default::default(),
    }),
    Precedence7,
};

// Level 7: Unary operators
Precedence7: AstNode = {
    "-" <expr:Precedence7> => {
        match expr {
            AstNode::字面量表达式(lit) => AstNode::字面量表达式(LiteralExpression {
                value: match lit.value {
                    crate::parser::ast::LiteralValue::整数(n) => crate::parser::ast::LiteralValue::整数(-n),
                    crate::parser::ast::LiteralValue::浮点数(f) => crate::parser::ast::LiteralValue::浮点数(-f),
                    other => other,
                },
                span: Default::default(),
            }),
            other => other,
        }
    },
    Precedence8,
};

// Level 8: Postfix operators (field access, array subscript, function call)
Precedence8: AstNode = {
    <base:Precedence8> "." <field:Identifier> => {
        AstNode::字段访问表达式(FieldAccessExpression {
            object: Box::new(base),
            field,
            span: Default::default(),
        })
    },
    <array:Precedence8> "[" <index:Expr> "]" => {
        AstNode::数组访问表达式(ArrayAccessExpression {
            array: Box::new(array),
            index: Box::new(index),
            span: Default::default(),
        })
    },
    <callee:Precedence8> "(" <args:ExprList> ")" => {
        match callee {
            AstNode::标识符表达式(ident) => AstNode::函数调用表达式(FunctionCallExpression {
                callee: ident.name,
                arguments: args,
                span: Default::default(),
            }),
            _ => callee,
        }
    },
    <callee:Precedence8> "(" ")" => {
        match callee {
            AstNode::标识符表达式(ident) => AstNode::函数调用表达式(FunctionCallExpression {
                callee: ident.name,
                arguments: vec![],
                span: Default::default(),
            }),
            _ => callee,
        }
    },
    Primary,
};

// Primary expressions (literals, identifiers, parenthesized expressions)
// Note: Struct literals are parsed in Atom within parentheses to avoid ambiguity
// with blocks in control flow statements. To use struct literals as expressions,
// wrap them in parentheses: (Point { x: 1, y: 2 })
Primary: AstNode = {
    <name:Identifier> => AstNode::标识符表达式(IdentifierExpression {
        name,
        span: Default::default(),
    }),
    Atom,
};

// Atomic expressions - the lowest level
// Struct literals are only allowed here (in parentheses) to avoid ambiguity
Atom: AstNode = {
    BooleanLiteral,
    IntegerLiteral,
    FloatLiteral,
    StringLiteral,
    CharLiteral,
    ArrayLiteral,
    // Parenthesized expressions, including struct literals
    "(" <Expr> ")",
    // Struct literals (must be in safe context or parenthes)
    "(" <name:Identifier> "{" <fields:StructFieldValueList> "}" ")" => AstNode::结构体实例化表达式(StructLiteralExpression {
        struct_name: name,
        fields,
        span: Default::default(),
    }),
    "(" <name:Identifier> "{" "}" ")" => AstNode::结构体实例化表达式(StructLiteralExpression {
        struct_name: name,
        fields: vec![],
        span: Default::default(),
    }),
};



BooleanLiteral: AstNode = {
    "真" => AstNode::字面量表达式(LiteralExpression {
        value: LiteralValue::布尔(true),
        span: Default::default(),
    }),
    "假" => AstNode::字面量表达式(LiteralExpression {
        value: LiteralValue::布尔(false),
        span: Default::default(),
    }),
};

IntegerLiteral: AstNode = {
    <n:r"[0-9]+"> => AstNode::字面量表达式(LiteralExpression {
        value: LiteralValue::整数(n.parse().unwrap()),
        span: Default::default(),
    }),
};

FloatLiteral: AstNode = {
    <n:r"[0-9]+\.[0-9]+"> => AstNode::字面量表达式(LiteralExpression {
        value: LiteralValue::浮点数(n.parse().unwrap()),
        span: Default::default(),
    }),
};

StringLiteral: AstNode = {
    <s:r#""[^"]*""#> => AstNode::字面量表达式(LiteralExpression {
        value: LiteralValue::字符串(s[1..s.len()-1].to_string()),
        span: Default::default(),
    }),
};

CharLiteral: AstNode = {
    <c:r"'.'"> => AstNode::字面量表达式(LiteralExpression {
        value: LiteralValue::字符(c.chars().nth(1).unwrap()),
        span: Default::default(),
    }),
};

ArrayLiteral: AstNode = {
    "[" <elements:ExprList> "]" => AstNode::数组字面量表达式(ArrayLiteralExpression {
        elements,
        span: Default::default(),
    }),
    "[" "]" => AstNode::数组字面量表达式(ArrayLiteralExpression {
        elements: vec![],
        span: Default::default(),
    }),
};


StructFieldValueList: Vec<StructFieldValue> = {
    <fields:Comma<StructFieldValue>> => fields,
};

StructFieldValue: StructFieldValue = {
    <name:Identifier> ":" <value:Expr> => StructFieldValue {
        name,
        value: Box::new(value),
        span: Default::default(),
    },
};

ParameterList: Vec<Parameter> = {
    <params:Comma<Parameter>> => params,
};

Parameter: Parameter = {
    <name:Identifier> ":" <type_annotation:Type> => Parameter {
        name,
        type_annotation: Some(type_annotation),
        span: Default::default(),
    },
    <name:Identifier> => Parameter {
        name,
        type_annotation: None,
        span: Default::default(),
    },
};

// Helper macro for comma-separated lists
Comma<T>: Vec<T> = {
    <first:T> => vec![first],
    <first:T> "," <rest:Comma<T>> => {
        let mut rest = rest;
        rest.insert(0, first);
        rest
    },
};

ExprList: Vec<AstNode> = {
    <exprs:Comma<Expr>> => exprs,
};

Type: TypeNode = {
    "整数" => TypeNode::基础类型(BasicType::整数),
    "浮点数" => TypeNode::基础类型(BasicType::浮点数),
    "布尔" => TypeNode::基础类型(BasicType::布尔),
    "字符" => TypeNode::基础类型(BasicType::字符),
    "字符串" => TypeNode::基础类型(BasicType::字符串),
    "空" => TypeNode::基础类型(BasicType::空),
    "数组" "<" <element_type:Type> ">" => TypeNode::数组类型(ArrayType {
        element_type: Box::new(element_type),
        size: None,
    }),
    // Custom types (struct names, etc.)
    <name:Identifier> => TypeNode::自定义类型(name),
};

Identifier: String = {
    <id:r"[a-zA-Z_][a-zA-Z0-9_]*"> => id.to_string(),
    <id:r"[\u4e00-\u9fff][\u4e00-\u9fffa-zA-Z0-9_]*"> => {
        match id {
            "变量" | "常量" | "函数" | "返回" | "如果" | "否则" | "当" | "对于" | "在" | "真" | "假" |
            "整数" | "浮点数" | "布尔" | "字符" | "字符串" | "空" | "数组" | "结构体" | "枚举" | "打印" =>
                panic!("Keyword used as identifier: {}", id),
            _ => id.to_string(),
        }
    },
};

IdentifierExpression: AstNode = {
    <name:Identifier> => AstNode::标识符表达式(IdentifierExpression {
        name,
        span: Default::default(),
    }),
};
