# Qi 语言规范文档

## 概述

Qi 语言是一门基于中文关键字的静态类型编程语言，文件后缀为 `.qi`。语言设计强调内存安全、零成本抽象和并发友好，同时提供直观的中文语法。

## 核心特性

- **纯中文语法**: 所有关键字和标准库 API 均使用中文
- **内存安全**: 编译期所有权与借用检查，无需垃圾回收
- **高性能并发**: M:N 协程调度，支持百万级并发
- **零成本抽象**: 高级特性在编译期优化掉，无运行时开销
- **跨平台**: 支持 Windows、Linux、macOS、WebAssembly

## 关键字系统

### 模块与导入
| 关键字 | 含义 | 类似于 |
| :----- | :--- | :----- |
| `包`   | 声明包名/模块名 | mod/namespace |
| `导入` | 导入模块或库    | use/#include |
| `公开` | 对外可见        | pub/extern |
| `私有` | 模块内可见      | private |
| `作为` | 引入别名        | as |

### 类型与变量
| 关键字   | 含义             | 类似于    |
| :------- | :--------------- | :-------- |
| `变量`   | 声明变量（可变） | let mut   |
| `不可变` | 声明不可变变量   | let       |
| `类型`   | 定义自定义类型   | type      |
| `结构体` | 定义结构体       | struct    |
| `枚举`   | 定义枚举         | enum      |
| `联合体` | 定义联合体       | union     |
| `实现`   | 实现方法或特性   | impl      |
| `特性`   | trait/接口       | trait     |
| `自我`   | 当前类型         | Self      |
| `自身`   | 当前对象         | self      |

### 控制流程
| 关键字 | 含义         | 类似于        |
| :----- | :----------- | :------------ |
| `如果` | 条件判断     | if            |
| `否则` | 否则分支     | else          |
| `匹配` | 模式匹配     | match         |
| `循环` | 无限循环     | loop          |
| `当`   | 条件循环     | while         |
| `对于` | for 循环     | for           |
| `中断` | 跳出循环     | break         |
| `继续` | 跳过当前循环 | continue      |
| `返回` | 返回函数结果 | return        |

### 函数与并发
| 关键字     | 含义         | 类似于 |
| :--------- | :----------- | :----- |
| `函数`     | 定义函数     | fn     |
| `异步`     | 异步函数     | async  |
| `等待`     | 等待异步完成 | await  |
| `返回类型` | 指定返回类型 | ->     |
| `启动`     | 启动协程     | spawn |

### 内存与所有权
| 关键字     | 含义          | 类似于 |
| :--------- | :------------ | :----- |
| `拥有`     | 拥有权标识    | (Rust) |
| `借用`     | 借用          | (Rust) |
| `移动`     | 所有权移动    | move   |
| `克隆`     | 显式复制      | clone  |
| `释放`     | 释放内存/资源 | drop   |
| `新建`     | 创建对象      | new    |
| `引用`     | 引用类型      | &      |
| `可变引用` | 可变引用      | &mut   |

### 基础数据类型
| 关键字 | 含义 | 类似于 |
| :--- | :--- | :--- |
| `整数` | 整型 | i32/int |
| `长整数` | 64 位整型 | i64/long |
| `浮点数` | 浮点型 | f64/double |
| `布尔` | 布尔型 | bool |
| `字符` | 单个字符 | char |
| `字符串` | 字符串类型 | String |
| `空` | 空类型 | void/() |
| `数组` | 数组类型 | array |
| `列表` | 顺序列表 | Vec/List |

### 特殊关键字
| 关键字       | 含义     | 用途               |
| :----------- | :------- | :----------------- |
| `真`         | 布尔真值 | `真` / `假`        |
| `假`         | 布尔假值 | `真` / `假`        |
| `空指针`     | 空指针   | `空指针`           |
| `主程序入口` | 主函数   | `主程序入口()`     |
| `打印`       | 标准输出 | `打印("消息")`     |
| `输入`       | 标准输入 | `变量 值 = 输入()` |

## 语法规范 (EBNF)

### 基础语法

```ebnf
<程序> ::= <包声明>? <导入声明>* <项定义>*

<包声明> ::= "包" <标识符> ";"
<导入声明> ::= "导入" <模块路径> ["作为" <标识符>] ";"
<模块路径> ::= <标识符> ("::" <标识符>)*

<标识符> ::= <中文字符> | <英文字符> ("_" <字符序列>)?
<字符序列> ::= <中文字符> | <英文字符> | <数字>
```

### 类型系统

```ebnf
<类型> ::= <基础类型>
        | <结构体类型>
        | <枚举类型>
        | <泛型类型>
        | <引用类型>
        | <指针类型>
        | "(" <类型> ")" ;

<基础类型> ::= "整数" | "长整数" | "浮点数"
              | "布尔" | "字符" | "字符串"
              | "空"
              | "数组" "<" <类型> ">"
              | "列表" "<" <类型> ">" ;

<结构体类型> ::= 标识符 ;
<枚举类型> ::= 标识符 ;

<泛型类型> ::= 标识符 "<" <类型参数列表> ">" ;
<类型参数列表> ::= <类型参数> ( "," <类型参数> )* ;
<类型参数> ::= 标识符 [ ":" <特性约束列表> ] ;
<特性约束列表> ::= <特性约束> ( "+" <特性约束> )* ;
<特性约束> ::= 标识符 ;

<引用类型> ::= "引用" "<" [ <生命周期标识> ] <类型> ">"
              | "可变引用" "<" [ <生命周期标识> ] <类型> ">" ;

<指针类型> ::= "指针" "<" <类型> ">" ;
```

### 生命周期系统

```ebnf
<生命周期标识> ::= "'" 标识符 ;   // 例如 'a, 'b, '静态
<生命周期参数列表> ::= <生命周期标识> ( "," <生命周期标识> )* ;
<函数生命周期声明> ::= "[" <生命周期参数列表> "]" ;
```

### 函数定义

```ebnf
<函数定义> ::= "函数" [ "<" <类型参数列表> ">" ]
               [ <函数生命周期声明> ]
               <函数名> "(" <参数列表>? ")" <返回类型> <代码块> ;

<返回类型> ::= "->" <类型> | "" ; // 默认为 "空"
<参数列表> ::= <参数> ( "," <参数> )* ;
<参数> ::= 标识符 ":" <类型> ;
```

### 特性与实现

```ebnf
<特性定义> ::= "特性" 标识符 [ "<" <类型参数列表>? ">" ] "{" <特性成员定义>* "}" ;
<特性成员定义> ::= "函数" <函数名> "(" <参数列表>? ")" <返回类型> ";" ;

<实现定义> ::= "实现" [ "<" <类型参数列表> ">" ]
               <目标> [ "对于" <类型> ] "{" <函数定义>* "}" ;
<目标> ::= 标识符 ; // 特性名称或类型名称
```

### 结构体与枚举

```ebnf
<结构体定义> ::= "结构体" 标识符 [ "<" <类型参数列表> ">" ] "{" <字段定义>* "}" ;
<字段定义> ::= 标识符 ":" <类型> "," ;

<枚举定义> ::= "枚举" 标识符 [ "<" <类型参数列表> ">" ] "{" <枚举成员>* "}" ;
<枚举成员> ::= 标识符 [ "(" <类型列表> ")" ] "," ;
<类型列表> ::= <类型> ( "," <类型> )* ;
```

### 控制流程

```ebnf
<如果语句> ::= "如果" <表达式> <代码块> [ "否则" <代码块> ] ;
<匹配语句> ::= "匹配" <表达式> "{" <匹配分支>* "}" ;
<匹配分支> ::= <模式> "=>" <代码块> | <模式> "=>" <表达式> "," ;
<循环语句> ::= "循环" <代码块> ;
<当语句> ::= "当" <表达式> <代码块> ;
<对于语句> ::= "对于" <标识符> "在" <表达式> <代码块> ;
```

### 变量声明

```ebnf
<变量声明> ::= ("变量" | "不可变") <标识符> [ ":" <类型> ] "=" <表达式> ";" ;
<常量声明> ::= "常量" <标识符> ":" <类型> "=" <表达式> ";" ;
<静态声明> ::= "静态" <标识符> ":" <类型> "=" <表达式> ";" ;
```

### 表达式

```ebnf
<表达式> ::= <字面量>
           | <标识符>
           | <函数调用>
           | <二元表达式>
           | <一元表达式>
           | <条件表达式>
           | <块表达式>
           | <字段访问>
           | <方法调用>
           | <索引访问> ;

<字面量> ::= <整数字面量> | <浮点数字面量> | <字符串字面量>
           | <字符字面量> | <布尔字面量> ;

<布尔字面量> ::= "真" | "假" ;

<函数调用> ::= <表达式> "(" <参数表达式列表>? ")" ;
<参数表达式列表> ::= <表达式> ( "," <表达式> )* ;

<二元表达式> ::= <表达式> <二元操作符> <表达式> ;
<一元表达式> ::= <一元操作符> <表达式> ;
```

### 操作符

- **算术**: `+`, `-`, `*`, `/`, `%`
- **逻辑**: `与`, `或`, `非`
- **比较**: `<`, `<=`, `>`, `>=`, `==`, `!=`
- **赋值**: `=`
- **成员访问**: `.`
- **命名空间**: `::`

## 语法示例

### 基础程序

```qi
包 示例;

导入 标准库.输入输出;

函数 主程序入口() {
    变量 名称 = "世界";
    打印("你好, {}!", 名称);

    不可变 年龄: 整数 = 25;
    如果 年龄 >= 18 {
        打印("成年人");
    } 否则 {
        打印("未成年");
    }
}
```

### 结构体与实现

```qi
结构体 用户 {
    ID: 整数,
    姓名: 字符串,
    年龄: 整数,
}

特性 可打印 {
    函数 打印信息(自身: 引用<自我>);
}

实现 可打印 对于 用户 {
    函数 打印信息(自身: 引用<自我>) {
        打印("用户: ID={}, 姓名={}, 年龄={}",
              自身.ID, 自身.姓名, 自身.年龄);
    }
}
```

### 函数与泛型

```qi
函数 <T: 可比较> 比较值(左: T, 右: T) -> 布尔 {
    返回 左 == 右;
}

函数 ['a] 获取引用<'a, T>(数据: 引用<'a, T>) -> 引用<'a, T> {
    返回 数据;
}
```

### 异步编程

```qi
异步 函数 网络请求(URL: 字符串) -> 结果<字符串, 错误> {
    等待 连接到服务器(URL);
    变量 响应 = 等待 发送请求("GET", "/");
    返回 结果::成功(响应);
}

函数 主程序入口() {
    启动 异步 {
        匹配 等待 网络请求("https://example.com") {
            结果::成功(数据) => 打印("收到: {}", 数据),
            结果::失败(错误) => 打印("错误: {}", 错误),
        }
    };
}
```

### 错误处理

```qi
函数 读取文件(路径: 字符串) -> 结果<字符串, 错误> {
    变量 文件 = 匹配 打开文件(路径) {
        成功(句柄) => 句柄,
        失败(错误) => 返回 结果::失败(错误),
    };

    变量 内容 = 读取所有内容(文件)?;
    返回 结果::成功(内容);
}
```

### 内存操作示例

```qi
函数 处理数据() {
    变量 数据1 = 列表<整数>{1, 2, 3};  // 数据1 拥有列表
    变量 数据2 = 数据1;                  // 所有权移动到 data2
    // 数据1 现在无效，使用会导致编译错误

    变量 数据3 = 数据2.克隆();           // 显式克隆
    // data2 和 data3 都有效

    打印列表(&数据2);                    // 传递引用，不转移所有权
    打印列表(&数据3);                    // 再次传递引用
}

函数 打印列表(列表: 引用<列表<整数>>) {
    对于 元素 在 列表 {
        打印("{}", 元素);
    }
}
```

## 编码规则

1. **字符编码**: 所有文件使用 UTF-8 编码
2. **注释**: 支持 `//` 单行注释和 `/* */` 多行注释
3. **语句结束**: 使用分号 `;` 结束语句
4. **代码块**: 使用大括号 `{}` 定义代码块
5. **标识符**: 支持中文和英文字符，推荐使用中文命名以提高可读性

这个语言规范为 Qi 语言的实现提供了详细的语法和语义指导，确保编译器开发的准确性和一致性。