

åœ¨ä»£ç ç”Ÿæˆä¸­å®Œå…¨å¯ç”¨å†…å­˜ç®¡ç†ç³»ç»Ÿ - è¯¦ç»†è®¡åˆ’

  ğŸ“Š å½“å‰çŠ¶å†µåˆ†æ

  âœ… å·²å®Œæˆéƒ¨åˆ†:

  1. å†…å­˜ç®¡ç†åŸºç¡€è®¾æ–½å·²å°±ç»ª:
    - MemoryManager - å®Œæ•´å®ç° âœ…
    - GarbageCollector - æ”¯æŒ Mark-Sweep, RefCount, Generational âœ…
    - AllocationStrategy - BumpAllocator, ArenaAllocator, HybridAllocator âœ…
    - ç»Ÿè®¡å’Œç›‘æ§ç³»ç»Ÿ âœ…
  2. è¿è¡Œæ—¶é›†æˆå·²å®Œæˆ:
    - RuntimeEnvironment.memory_manager å­—æ®µå·²å­˜åœ¨ âœ…
    - qi_runtime_alloc() FFIå‡½æ•°å·²å®ç° âœ…
    - qi_runtime_dealloc() FFIå‡½æ•°å·²å®ç° âœ…
  3. LLVM IRå£°æ˜å·²æ·»åŠ :
  declare ptr @qi_runtime_alloc(i64)
  declare i32 @qi_runtime_dealloc(ptr, i64)

  âŒ å½“å‰é—®é¢˜:

  1. ä»£ç ç”Ÿæˆå™¨ä»ä½¿ç”¨ alloca (æ ˆåˆ†é…):
    - æ‰€æœ‰å±€éƒ¨å˜é‡: %x = alloca i64
    - æ•°ç»„åˆ†é…: alloca [10 x i64]
    - ä¸´æ—¶å˜é‡å…¨éƒ¨åœ¨æ ˆä¸Š
  2. å †åˆ†é…æœªå¯ç”¨:
    - æ²¡æœ‰å®é™…è°ƒç”¨ @qi_runtime_alloc
    - é•¿ç”Ÿå‘½å‘¨æœŸå¯¹è±¡æ²¡æœ‰å †åˆ†é…
    - å¤§å¯¹è±¡æ²¡æœ‰ç‰¹æ®Šå¤„ç†
  3. GC æœªè§¦å‘:
    - æ²¡æœ‰ GC è§¦å‘ç‚¹
    - æ²¡æœ‰å¯¹è±¡ç”Ÿå‘½å‘¨æœŸè·Ÿè¸ª
    - æ²¡æœ‰å†…å­˜å‹åŠ›æ£€æµ‹

  ---
  ğŸ¯ å®æ–½è®¡åˆ’

  é˜¶æ®µä¸€: åˆ†æå’Œè®¾è®¡ (å·²å®Œæˆ)

  ç›®æ ‡: ç†è§£å½“å‰æ¶æ„,è®¾è®¡é›†æˆæ–¹æ¡ˆ

  âœ… åˆ†æä»£ç ç”Ÿæˆå™¨å†…å­˜åˆ†é…æ¨¡å¼âœ… åˆ†æè¿è¡Œæ—¶å†…å­˜ç®¡ç†å™¨æ¥å£âœ… ç¡®è®¤FFIæ¥å£å·²å®ç°

  ---
  é˜¶æ®µäºŒ: å¢å¼ºå†…å­˜åˆ†é…ç­–ç•¥

  ç›®æ ‡: æ™ºèƒ½åŒºåˆ†æ ˆåˆ†é…å’Œå †åˆ†é…

  2.1 å®šä¹‰åˆ†é…ç­–ç•¥è§„åˆ™

  // åœ¨ codegen/builder.rs ä¸­æ·»åŠ 
  enum AllocationTarget {
      Stack,   // æ ˆ: å°å‹å±€éƒ¨å˜é‡, ç”Ÿå‘½å‘¨æœŸæ˜ç¡®
      Heap,    // å †: å¤§å¯¹è±¡, é€ƒé€¸å¯¹è±¡, åŠ¨æ€å¤§å°
  }

  impl IrBuilder {
      fn determine_allocation_target(&self, node: &AstNode) -> AllocationTarget {
          match node {
              // å°å‹åŸºæœ¬ç±»å‹ -> æ ˆ
              AstNode::å˜é‡å£°æ˜(var) if is_small_type(&var.type_annotation) => Stack,

              // æ•°ç»„, å­—ç¬¦ä¸², ç»“æ„ä½“ -> å †
              AstNode::æ•°ç»„å­—é¢é‡è¡¨è¾¾å¼(_) => Heap,
              AstNode::å­—ç¬¦ä¸²å¸¸é‡(_) => Heap,
              AstNode::ç»“æ„ä½“å®ä¾‹åŒ–è¡¨è¾¾å¼(_) => Heap,

              // é»˜è®¤æ ˆ
              _ => Stack,
          }
      }
  }

  2.2 å®ç°åˆ†é…å‡½æ•°ç”Ÿæˆ

  fn generate_heap_allocation(&mut self, size: usize, type_name: &str) -> String {
      let dest = self.new_temp();
      let size_temp = self.new_temp();

      format!(
          "{} = call ptr @qi_runtime_alloc(i64 {})\n\
           {} = bitcast ptr {} to {}*",
          size_temp, size, dest, size_temp, type_name
      )
  }

  fn generate_stack_allocation(&mut self, type_name: &str) -> String {
      let dest = self.new_temp();
      format!("{} = alloca {}, align 8", dest, type_name)
  }

  ---
  é˜¶æ®µä¸‰: ä¿®æ”¹ä»£ç ç”Ÿæˆå™¨

  3.1 å˜é‡å£°æ˜

  å½“å‰:
  %x = alloca i64, align 8
  store i64 42, ptr %x

  ç›®æ ‡:
  ; å°å‹å˜é‡ä»ç”¨æ ˆ
  %x = alloca i64, align 8
  store i64 42, ptr %x

  ; å¤§å¯¹è±¡ç”¨å †
  %1 = call ptr @qi_runtime_alloc(i64 1024)
  %arr = bitcast ptr %1 to [256 x i32]*

  3.2 å­—ç¬¦ä¸²åˆ†é…

  ç›®æ ‡:
  ; å­—ç¬¦ä¸²æ€»æ˜¯å †åˆ†é…
  %str_size = add i64 %len, 1  ; +1 for null terminator
  %str_ptr = call ptr @qi_runtime_alloc(i64 %str_size)
  ; ... å¤åˆ¶å­—ç¬¦ä¸²å†…å®¹

  3.3 æ•°ç»„åˆ†é…

  ç›®æ ‡:
  ; å°æ•°ç»„ (<= 64 å…ƒç´ ) -> æ ˆ
  %small_arr = alloca [10 x i64], align 8

  ; å¤§æ•°ç»„ (> 64 å…ƒç´ ) -> å †
  %arr_size = mul i64 %count, 8  ; 8 bytes per i64
  %arr_ptr = call ptr @qi_runtime_alloc(i64 %arr_size)
  %big_arr = bitcast ptr %arr_ptr to [1000 x i64]*

  ---
  é˜¶æ®µå››: å®ç°å¯¹è±¡ç”Ÿå‘½å‘¨æœŸè·Ÿè¸ª

  4.1 æ·»åŠ å…ƒæ•°æ®è®°å½•

  struct AllocationInfo {
      ptr: String,          // LLVMä¸´æ—¶å˜é‡å
      size: usize,          // åˆ†é…å¤§å°
      type_name: String,    // ç±»å‹å
      scope_level: usize,   // ä½œç”¨åŸŸæ·±åº¦
      is_heap: bool,        // æ˜¯å¦å †åˆ†é…
  }

  impl IrBuilder {
      allocations: Vec<AllocationInfo>,  // è·Ÿè¸ªæ‰€æœ‰åˆ†é…

      fn record_allocation(&mut self, info: AllocationInfo) {
          self.allocations.push(info);
      }
  }

  4.2 ä½œç”¨åŸŸé€€å‡ºæ—¶é‡Šæ”¾

  fn generate_scope_cleanup(&mut self, scope_level: usize) -> String {
      let mut ir = String::new();

      // æŸ¥æ‰¾è¯¥ä½œç”¨åŸŸçš„å †åˆ†é…
      for alloc in &self.allocations {
          if alloc.scope_level == scope_level && alloc.is_heap {
              ir.push_str(&format!(
                  "call i32 @qi_runtime_dealloc(ptr {}, i64 {})\n",
                  alloc.ptr, alloc.size
              ));
          }
      }

      // ç§»é™¤è¯¥ä½œç”¨åŸŸçš„åˆ†é…è®°å½•
      self.allocations.retain(|a| a.scope_level != scope_level);
      ir
  }

  ---
  é˜¶æ®µäº”: GC è§¦å‘æœºåˆ¶

  5.1 æ·»åŠ  GC å‡½æ•°å£°æ˜

  // åœ¨ generate_header() ä¸­æ·»åŠ 
  ir.push_str("declare void @qi_runtime_gc_collect()\n");
  ir.push_str("declare i64 @qi_runtime_gc_should_collect()\n");

  5.2 åœ¨åˆ†é…ç‚¹æ£€æŸ¥ GC

  ; æ¯æ¬¡å¤§åˆ†é…å‰æ£€æŸ¥æ˜¯å¦éœ€è¦ GC
  %should_gc = call i64 @qi_runtime_gc_should_collect()
  %need_gc = icmp ne i64 %should_gc, 0
  br i1 %need_gc, label %do_gc, label %skip_gc

  do_gc:
      call void @qi_runtime_gc_collect()
      br label %skip_gc

  skip_gc:
      ; ç»§ç»­åˆ†é…
      %ptr = call ptr @qi_runtime_alloc(i64 %size)

  5.3 å®ç° GC FFI å‡½æ•°

  // åœ¨ runtime/executor.rs ä¸­æ·»åŠ 
  #[no_mangle]
  pub extern "C" fn qi_runtime_gc_should_collect() -> i64 {
      unsafe {
          if let Some(runtime_mutex) = RUNTIME.as_ref() {
              if let Ok(runtime) = runtime_mutex.lock() {
                  if runtime.memory_manager.should_collect() {
                      return 1;
                  }
              }
          }
      }
      0
  }

  #[no_mangle]
  pub extern "C" fn qi_runtime_gc_collect() {
      unsafe {
          if let Some(runtime_mutex) = RUNTIME.as_ref() {
              if let Ok(mut runtime) = runtime_mutex.lock() {
                  if let Err(e) = runtime.memory_manager.collect() {
                      eprintln!("GCå¤±è´¥: {}", e);
                  }
              }
          }
      }
  }

  ---
  é˜¶æ®µå…­: å†…å­˜ç®¡ç†å™¨å¢å¼º

  6.1 å®ç° MemoryManager ç¼ºå¤±æ–¹æ³•

  // åœ¨ runtime/memory/manager.rs ä¸­
  impl MemoryManager {
      pub fn should_collect(&self) -> bool {
          let usage_ratio = self.get_usage_ratio();
          usage_ratio > self.gc_threshold
      }

      pub fn collect(&mut self) -> MemoryResult<usize> {
          // è§¦å‘åƒåœ¾å›æ”¶
          self.gc.collect()
      }

      fn get_usage_ratio(&self) -> f64 {
          if self.capacity == 0 {
              0.0
          } else {
              self.allocated as f64 / self.capacity as f64
          }
      }
  }

  ---
  é˜¶æ®µä¸ƒ: æµ‹è¯•å’ŒéªŒè¯

  7.1 å•å…ƒæµ‹è¯•

  #[cfg(test)]
  mod tests {
      #[test]
      fn test_heap_allocation_codegen() {
          let source = "å˜é‡ å¤§æ•°ç»„ = [1; 1000];";
          let ir = generate_ir(source);

          assert!(ir.contains("@qi_runtime_alloc"));
          assert!(!ir.contains("alloca [1000"));
      }

      #[test]
      fn test_gc_trigger() {
          let source = r#"
              å‡½æ•° å…¥å£() {
                  å˜é‡ i = 0;
                  å½“ i < 1000 {
                      å˜é‡ arr = [0; 100];  // è§¦å‘å¤šæ¬¡åˆ†é…
                      i = i + 1;
                  }
              }
          "#;
          let ir = generate_ir(source);

          assert!(ir.contains("@qi_runtime_gc_should_collect"));
          assert!(ir.contains("@qi_runtime_gc_collect"));
      }
  }

  7.2 é›†æˆæµ‹è¯•

  åˆ›å»ºç¤ºä¾‹ç¨‹åºæµ‹è¯•å†…å­˜ç®¡ç†:

  // ç¤ºä¾‹/å†…å­˜ç®¡ç†/å †åˆ†é…æµ‹è¯•.qi
  åŒ… ä¸»ç¨‹åº;

  å‡½æ•° å…¥å£() {
      // æµ‹è¯•å¤§æ•°ç»„å †åˆ†é…
      å˜é‡ å¤§æ•°ç»„ = [0; 10000];
      æ‰“å°è¡Œ("å¤§æ•°ç»„åˆ†é…æˆåŠŸ");

      // æµ‹è¯•å­—ç¬¦ä¸²å †åˆ†é…
      å˜é‡ é•¿å­—ç¬¦ä¸² = "é‡å¤".é‡å¤(1000);
      æ‰“å°è¡Œ("å­—ç¬¦ä¸²åˆ†é…æˆåŠŸ");

      // æµ‹è¯•å¾ªç¯åˆ†é…å’ŒGC
      å˜é‡ i = 0;
      å½“ i < 100 {
          å˜é‡ ä¸´æ—¶æ•°ç»„ = [0; 100];
          i = i + 1;
      }
      æ‰“å°è¡Œ("å¾ªç¯åˆ†é…å®Œæˆ");
  }

  ---
  ğŸ“‹ å®æ–½ä¼˜å…ˆçº§

  1. P0 (ç«‹å³):
    - âœ… åˆ†æå®Œæˆ
    - ğŸ”„ å¢å¼º FFI æ¥å£ (GCå‡½æ•°)
  2. P1 (æ ¸å¿ƒåŠŸèƒ½):
    - å®ç°åˆ†é…ç­–ç•¥åˆ¤æ–­
    - ä¿®æ”¹ä»£ç ç”Ÿæˆå™¨æ”¯æŒå †åˆ†é…
    - æ·»åŠ ä½œç”¨åŸŸæ¸…ç†
  3. P2 (ä¼˜åŒ–):
    - å®ç° GC è§¦å‘
    - å¯¹è±¡ç”Ÿå‘½å‘¨æœŸè·Ÿè¸ª
    - å†…å­˜ç»Ÿè®¡
  4. P3 (å®Œå–„):
    - æ€§èƒ½ä¼˜åŒ–
    - é«˜çº§ GC ç­–ç•¥
    - å†…å­˜æ³„æ¼æ£€æµ‹

  ---
  âš ï¸ é£é™©å’Œæ³¨æ„äº‹é¡¹

  1. å‘åå…¼å®¹: ç°æœ‰æ ˆåˆ†é…ä»£ç ä»éœ€æ­£å¸¸å·¥ä½œ
  2. æ€§èƒ½å½±å“: å †åˆ†é…æ¯”æ ˆæ…¢,éœ€è¦æƒè¡¡
  3. GCæš‚åœæ—¶é—´: éœ€è¦æ§åˆ¶åœ¨å¯æ¥å—èŒƒå›´
  4. å¹¶å‘å®‰å…¨: GC ä¸åç¨‹çš„äº¤äº’éœ€è¦å°å¿ƒå¤„ç†
  5. è°ƒè¯•å›°éš¾: å†…å­˜é—®é¢˜éš¾ä»¥å®šä½,éœ€è¦è¯¦ç»†æ—¥å¿—

  ---
  âœ… æˆåŠŸæ ‡å‡†

  1. âœ… å¤§å¯¹è±¡è‡ªåŠ¨ä½¿ç”¨å †åˆ†é…
  2. âœ… å°å¯¹è±¡ç»§ç»­ä½¿ç”¨æ ˆåˆ†é…(æ€§èƒ½)
  3. âœ… å†…å­˜è‡ªåŠ¨å›æ”¶,æ— æ³„æ¼
  4. âœ… GC åœ¨å†…å­˜å‹åŠ›æ—¶è‡ªåŠ¨è§¦å‘
  5. âœ… æ‰€æœ‰ç°æœ‰ç¤ºä¾‹ç¨‹åºæ­£å¸¸è¿è¡Œ
  6. âœ… æ–°å¢å†…å­˜ç®¡ç†ç¤ºä¾‹ç¨‹åºéªŒè¯åŠŸèƒ½

  ---
  è¿™å°±æ˜¯å®Œæ•´çš„å®æ–½è®¡åˆ’ï¼æˆ‘ä»¬å·²ç»æœ‰äº†å¾ˆå¥½çš„åŸºç¡€,ç°åœ¨éœ€è¦é€æ­¥å°†å†…å­˜ç®¡ç†ç³»ç»Ÿå®Œå…¨é›†æˆåˆ°ä»£ç ç”Ÿæˆæµç¨‹ä¸­ã€‚