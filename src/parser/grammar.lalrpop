use crate::parser::ast::*;

grammar;

pub Program: Program = {
    <package:PackageDeclaration?> <imports:ImportStatement*> <statements:Statement*> => Program {
        package_name: package,
        imports,
        statements,
        source_span: Default::default(),
    }
};

PackageDeclaration: String = {
    "包" <name:Identifier> ";" => name
};

ImportStatement: ImportStatement = {
    "导入" <path:ModulePath> ";" => ImportStatement {
        module_path: path,
        items: None,
        alias: None,
        span: Default::default(),
    },
    "导入" <path:ModulePath> "作为" <alias:Identifier> ";" => ImportStatement {
        module_path: path,
        items: None,
        alias: Some(alias),
        span: Default::default(),
    }
};

ModulePath: Vec<String> = {
    <first:Identifier> <rest:("." <Identifier>)*> => {
        let mut path = vec![first];
        path.extend(rest);
        path
    }
};

Statement: AstNode = {
    VariableDeclaration,
    FunctionDeclaration,
    AsyncFunctionDeclaration,
    TypeDeclaration,
    ReturnStatement,
    IfStatement,
    WhileStatement,
    ForStatement,
    <e:Expr> ";" => AstNode::表达式语句(ExpressionStatement {
        expression: Box::new(e),
        span: Default::default(),
    }),
};

VariableDeclaration: AstNode = {
    "变量" <name:Identifier> ":" <type_annotation:Type> "=" <value:Expr> ";" => AstNode::变量声明(VariableDeclaration {
        name,
        type_annotation: Some(type_annotation),
        initializer: Some(Box::new(value)),
        is_mutable: true,
        span: Default::default(),
    }),
    "变量" <name:Identifier> "=" <value:Expr> ";" => AstNode::变量声明(VariableDeclaration {
        name,
        type_annotation: None,
        initializer: Some(Box::new(value)),
        is_mutable: true,
        span: Default::default(),
    }),
    "常量" <name:Identifier> ":" <type_annotation:Type> "=" <value:Expr> ";" => AstNode::变量声明(VariableDeclaration {
        name,
        type_annotation: Some(type_annotation),
        initializer: Some(Box::new(value)),
        is_mutable: false,
        span: Default::default(),
    }),
    "常量" <name:Identifier> "=" <value:Expr> ";" => AstNode::变量声明(VariableDeclaration {
        name,
        type_annotation: None,
        initializer: Some(Box::new(value)),
        is_mutable: false,
        span: Default::default(),
    }),
};

Visibility: Visibility = {
    "公开" => Visibility::公开,
    => Visibility::私有,  // Default to private if not specified
};

FunctionDeclaration: AstNode = {
    // 带接收器的函数(方法) - Go 风格
    <vis:Visibility> "函数" "(" <receiver_name:ReceiverIdentifier> <receiver_type:Identifier> ")" <name:Identifier> "(" ")" ":" <return_type:Type> "{" <body:Statement*> "}" => AstNode::方法声明(MethodDeclaration {
        receiver_name,
        receiver_type,
        is_receiver_mutable: false,
        method_name: name,
        parameters: vec![],
        return_type: Some(return_type),
        body,
        visibility: vis,
        span: Default::default(),
    }),
    <vis:Visibility> "函数" "(" <receiver_name:ReceiverIdentifier> <receiver_type:Identifier> ")" <name:Identifier> "(" ")" "{" <body:Statement*> "}" => AstNode::方法声明(MethodDeclaration {
        receiver_name,
        receiver_type,
        is_receiver_mutable: false,
        method_name: name,
        parameters: vec![],
        return_type: None,
        body,
        visibility: vis,
        span: Default::default(),
    }),
    <vis:Visibility> "函数" "(" <receiver_name:ReceiverIdentifier> <receiver_type:Identifier> ")" <name:Identifier> "(" <params:ParameterList> ")" ":" <return_type:Type> "{" <body:Statement*> "}" => AstNode::方法声明(MethodDeclaration {
        receiver_name,
        receiver_type,
        is_receiver_mutable: false,
        method_name: name,
        parameters: params,
        return_type: Some(return_type),
        body,
        visibility: vis,
        span: Default::default(),
    }),
    <vis:Visibility> "函数" "(" <receiver_name:ReceiverIdentifier> <receiver_type:Identifier> ")" <name:Identifier> "(" <params:ParameterList> ")" "{" <body:Statement*> "}" => AstNode::方法声明(MethodDeclaration {
        receiver_name,
        receiver_type,
        is_receiver_mutable: false,
        method_name: name,
        parameters: params,
        return_type: None,
        body,
        visibility: vis,
        span: Default::default(),
    }),
    // 可变接收器的函数
    <vis:Visibility> "函数" "(" "变量" <receiver_name:ReceiverIdentifier> <receiver_type:Identifier> ")" <name:Identifier> "(" ")" ":" <return_type:Type> "{" <body:Statement*> "}" => AstNode::方法声明(MethodDeclaration {
        receiver_name,
        receiver_type,
        is_receiver_mutable: true,
        method_name: name,
        parameters: vec![],
        return_type: Some(return_type),
        body,
        visibility: vis,
        span: Default::default(),
    }),
    <vis:Visibility> "函数" "(" "变量" <receiver_name:ReceiverIdentifier> <receiver_type:Identifier> ")" <name:Identifier> "(" ")" "{" <body:Statement*> "}" => AstNode::方法声明(MethodDeclaration {
        receiver_name,
        receiver_type,
        is_receiver_mutable: true,
        method_name: name,
        parameters: vec![],
        return_type: None,
        body,
        visibility: vis,
        span: Default::default(),
    }),
    <vis:Visibility> "函数" "(" "变量" <receiver_name:ReceiverIdentifier> <receiver_type:Identifier> ")" <name:Identifier> "(" <params:ParameterList> ")" ":" <return_type:Type> "{" <body:Statement*> "}" => AstNode::方法声明(MethodDeclaration {
        receiver_name,
        receiver_type,
        is_receiver_mutable: true,
        method_name: name,
        parameters: params,
        return_type: Some(return_type),
        body,
        visibility: vis,
        span: Default::default(),
    }),
    <vis:Visibility> "函数" "(" "变量" <receiver_name:ReceiverIdentifier> <receiver_type:Identifier> ")" <name:Identifier> "(" <params:ParameterList> ")" "{" <body:Statement*> "}" => AstNode::方法声明(MethodDeclaration {
        receiver_name,
        receiver_type,
        is_receiver_mutable: true,
        method_name: name,
        parameters: params,
        return_type: None,
        body,
        visibility: vis,
        span: Default::default(),
    }),
    // 普通函数(无接收器)
    <vis:Visibility> "函数" <name:Identifier> "(" ")" ":" <return_type:Type> "{" <body:Statement*> "}" => AstNode::函数声明(FunctionDeclaration {
        name,
        parameters: vec![],
        return_type: Some(return_type),
        body,
        visibility: vis,
        span: Default::default(),
    }),
    <vis:Visibility> "函数" <name:Identifier> "(" ")" "{" <body:Statement*> "}" => AstNode::函数声明(FunctionDeclaration {
        name,
        parameters: vec![],
        return_type: None,
        body,
        visibility: vis,
        span: Default::default(),
    }),
    <vis:Visibility> "函数" <name:Identifier> "(" <params:ParameterList> ")" ":" <return_type:Type> "{" <body:Statement*> "}" => AstNode::函数声明(FunctionDeclaration {
        name,
        parameters: params,
        return_type: Some(return_type),
        body,
        visibility: vis,
        span: Default::default(),
    }),
    <vis:Visibility> "函数" <name:Identifier> "(" <params:ParameterList> ")" "{" <body:Statement*> "}" => AstNode::函数声明(FunctionDeclaration {
        name,
        parameters: params,
        return_type: None,
        body,
        visibility: vis,
        span: Default::default(),
    }),
};

// Async function declarations
AsyncFunctionDeclaration: AstNode = {
    // Async function without receiver
    <vis:Visibility> "异步" "函数" <name:Identifier> "(" ")" ":" <return_type:Type> "{" <body:Statement*> "}" => AstNode::异步函数声明(AsyncFunctionDeclaration {
        name,
        parameters: vec![],
        return_type: Some(return_type),
        body,
        visibility: vis,
        span: Default::default(),
    }),
    <vis:Visibility> "异步" "函数" <name:Identifier> "(" ")" "{" <body:Statement*> "}" => AstNode::异步函数声明(AsyncFunctionDeclaration {
        name,
        parameters: vec![],
        return_type: None,
        body,
        visibility: vis,
        span: Default::default(),
    }),
    <vis:Visibility> "异步" "函数" <name:Identifier> "(" <params:ParameterList> ")" ":" <return_type:Type> "{" <body:Statement*> "}" => AstNode::异步函数声明(AsyncFunctionDeclaration {
        name,
        parameters: params,
        return_type: Some(return_type),
        body,
        visibility: vis,
        span: Default::default(),
    }),
    <vis:Visibility> "异步" "函数" <name:Identifier> "(" <params:ParameterList> ")" "{" <body:Statement*> "}" => AstNode::异步函数声明(AsyncFunctionDeclaration {
        name,
        parameters: params,
        return_type: None,
        body,
        visibility: vis,
        span: Default::default(),
    }),
};

ReturnStatement: AstNode = {
    "返回" <value:Expr> ";" => AstNode::返回语句(ReturnStatement {
        value: Some(Box::new(value)),
        span: Default::default(),
    }),
    "返回" ";" => AstNode::返回语句(ReturnStatement {
        value: None,
        span: Default::default(),
    }),
};

Block: Vec<AstNode> = {
    "{" <statements:Statement*> "}" => statements
};

IfStatement: AstNode = {
    IfWithElse,
    IfWithoutElse,
};

// If statements with else (higher precedence to resolve dangling-else)
IfWithElse: AstNode = {
    "如果" <condition:Expr> <then_branch:Block> "否则" <else_branch:Block> => {
        AstNode::如果语句(IfStatement {
            condition: Box::new(condition),
            then_branch,
            else_branch: Some(Box::new(AstNode::块语句(BlockStatement {
                statements: else_branch,
                span: Default::default(),
            }))),
            span: Default::default(),
        })
    },
    "如果" <condition:Expr> <then_branch:Block> "否则如果" <else_if:IfWithElse> => {
        AstNode::如果语句(IfStatement {
            condition: Box::new(condition),
            then_branch,
            else_branch: Some(Box::new(else_if)),
            span: Default::default(),
        })
    },
};

// If statements without else
IfWithoutElse: AstNode = {
    "如果" <condition:Expr> <then_branch:Block> => {
        AstNode::如果语句(IfStatement {
            condition: Box::new(condition),
            then_branch,
            else_branch: None,
            span: Default::default(),
        })
    },
};

WhileStatement: AstNode = {
    "当" <condition:Expr> <body:Block> => AstNode::当语句(WhileStatement {
        condition: Box::new(condition),
        body,
        span: Default::default(),
    }),
};

ForStatement: AstNode = {
    "对于" <variable:Identifier> "在" <range:Expr> <body:Block> => AstNode::对于语句(ForStatement {
        variable,
        range: Box::new(range),
        body,
        span: Default::default(),
    }),
};


TypeDeclaration: AstNode = {
    <vis:Visibility> "类型" <name:Identifier> "{" <fields:StructFieldList> "}" => AstNode::结构体声明(StructDeclaration {
        name,
        fields,
        methods: vec![],
        visibility: vis,
        span: Default::default(),
    }),
    <vis:Visibility> "类型" <name:Identifier> "{" "}" => AstNode::结构体声明(StructDeclaration {
        name,
        fields: vec![],
        methods: vec![],
        visibility: vis,
        span: Default::default(),
    }),
};

StructFieldList: Vec<StructField> = {
    <fields:SemiSeparated<StructField>> => fields,
};

StructField: StructField = {
    <vis:Visibility> <type_annotation:Type> <name:Identifier> => StructField {
        name,
        type_annotation,
        is_embedded: false,
        visibility: vis,
        span: Default::default(),
    },
};
// Expression hierarchy using tiered approach like Solang
// Each level handles operators of the same precedence
Expr: AstNode = {
    Precedence1,
};

// Level 1: Assignment (lowest precedence, right-associative)
// Only Precedence8 (postfix) expressions can be assigned to (identifiers, field access, array subscript)
Precedence1: AstNode = {
    <left:Precedence8> "=" <right:Precedence1> => {
        // Validate that left is a valid LValue
        match &left {
            AstNode::标识符表达式(_) |
            AstNode::字段访问表达式(_) |
            AstNode::数组访问表达式(_) => {
                AstNode::赋值表达式(AssignmentExpression {
                    target: Box::new(left),
                    value: Box::new(right),
                    span: Default::default(),
                })
            },
            _ => panic!("Invalid assignment target: only identifiers, field access, and array subscript are allowed")
        }
    },
    Precedence2,
};

// Level 2: Logical OR
Precedence2: AstNode = {
    <left:Precedence2> "或" <right:Precedence3> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::或,
        right: Box::new(right),
        span: Default::default(),
    }),
    <left:Precedence2> "||" <right:Precedence3> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::或,
        right: Box::new(right),
        span: Default::default(),
    }),
    Precedence3,
};

// Level 3: Logical AND
Precedence3: AstNode = {
    <left:Precedence3> "与" <right:Precedence4> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::与,
        right: Box::new(right),
        span: Default::default(),
    }),
    <left:Precedence3> "&&" <right:Precedence4> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::与,
        right: Box::new(right),
        span: Default::default(),
    }),
    Precedence4,
};

// Level 4: Comparison operators
Precedence4: AstNode = {
    <left:Precedence5> "==" <right:Precedence5> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::等于,
        right: Box::new(right),
        span: Default::default(),
    }),
    <left:Precedence5> "!=" <right:Precedence5> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::不等于,
        right: Box::new(right),
        span: Default::default(),
    }),
    <left:Precedence5> ">" <right:Precedence5> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::大于,
        right: Box::new(right),
        span: Default::default(),
    }),
    <left:Precedence5> ">=" <right:Precedence5> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::大于等于,
        right: Box::new(right),
        span: Default::default(),
    }),
    <left:Precedence5> "<" <right:Precedence5> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::小于,
        right: Box::new(right),
        span: Default::default(),
    }),
    <left:Precedence5> "<=" <right:Precedence5> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::小于等于,
        right: Box::new(right),
        span: Default::default(),
    }),
    Precedence5,
};

// Level 5: Addition and subtraction
Precedence5: AstNode = {
    <left:Precedence5> "+" <right:Precedence6> => {
        // Check if both operands are strings - if so, create StringConcatExpression
        let is_string_concat = match (&left, &right) {
            (AstNode::字面量表达式(lit_left), AstNode::字面量表达式(lit_right)) => {
                matches!(&lit_left.value, LiteralValue::字符串(_)) &&
                matches!(&lit_right.value, LiteralValue::字符串(_))
            },
            (AstNode::字面量表达式(lit), _) => matches!(&lit.value, LiteralValue::字符串(_)),
            (_, AstNode::字面量表达式(lit)) => matches!(&lit.value, LiteralValue::字符串(_)),
            _ => false,
        };

        if is_string_concat {
            AstNode::字符串连接表达式(StringConcatExpression {
                left: Box::new(left),
                right: Box::new(right),
                span: Default::default(),
            })
        } else {
            AstNode::二元操作表达式(BinaryExpression {
                left: Box::new(left),
                operator: BinaryOperator::加,
                right: Box::new(right),
                span: Default::default(),
            })
        }
    },
    <left:Precedence5> "-" <right:Precedence6> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::减,
        right: Box::new(right),
        span: Default::default(),
    }),
    Precedence6,
};

// Level 6: Multiplication, division, and modulo
Precedence6: AstNode = {
    <left:Precedence6> "*" <right:Precedence7> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::乘,
        right: Box::new(right),
        span: Default::default(),
    }),
    <left:Precedence6> "/" <right:Precedence7> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::除,
        right: Box::new(right),
        span: Default::default(),
    }),
    <left:Precedence6> "%" <right:Precedence7> => AstNode::二元操作表达式(BinaryExpression {
        left: Box::new(left),
        operator: BinaryOperator::取余,
        right: Box::new(right),
        span: Default::default(),
    }),
    Precedence7,
};

// Level 7: Unary operators
Precedence7: AstNode = {
    "等待" <expr:Precedence7> => AstNode::等待表达式(AwaitExpression {
        expression: Box::new(expr),
        span: Default::default(),
    }),
    "-" <expr:Precedence7> => {
        match expr {
            AstNode::字面量表达式(lit) => AstNode::字面量表达式(LiteralExpression {
                value: match lit.value {
                    crate::parser::ast::LiteralValue::整数(n) => crate::parser::ast::LiteralValue::整数(-n),
                    crate::parser::ast::LiteralValue::浮点数(f) => crate::parser::ast::LiteralValue::浮点数(-f),
                    other => other,
                },
                span: Default::default(),
            }),
            other => other,
        }
    },
    Precedence8,
};

// Level 8: Postfix operators (field access, array subscript, function call)
Precedence8: AstNode = {
    <base:Precedence8> "." <field:Identifier> => {
        AstNode::字段访问表达式(FieldAccessExpression {
            object: Box::new(base),
            field,
            span: Default::default(),
        })
    },
    <array:Precedence8> "[" <index:Expr> "]" => {
        AstNode::数组访问表达式(ArrayAccessExpression {
            array: Box::new(array),
            index: Box::new(index),
            span: Default::default(),
        })
    },
    <callee:Precedence8> "(" <args:ExprList> ")" => {
        match callee {
            AstNode::标识符表达式(ident) => AstNode::函数调用表达式(FunctionCallExpression {
                callee: ident.name,
                arguments: args,
                span: Default::default(),
            }),
            AstNode::字段访问表达式(field_access) => AstNode::方法调用表达式(MethodCallExpression {
                object: field_access.object,
                method_name: field_access.field,
                arguments: args,
                span: Default::default(),
            }),
            _ => callee,
        }
    },
    <callee:Precedence8> "(" ")" => {
        match callee {
            AstNode::标识符表达式(ident) => AstNode::函数调用表达式(FunctionCallExpression {
                callee: ident.name,
                arguments: vec![],
                span: Default::default(),
            }),
            AstNode::字段访问表达式(field_access) => AstNode::方法调用表达式(MethodCallExpression {
                object: field_access.object,
                method_name: field_access.field,
                arguments: vec![],
                span: Default::default(),
            }),
            _ => callee,
        }
    },
    Primary,
};

// Primary expressions (literals, identifiers, parenthesized expressions)
// Note: Struct literals are parsed in Atom within parentheses to avoid ambiguity
// with blocks in control flow statements. To use struct literals as expressions,
// wrap them in parentheses: (Point { x: 1, y: 2 })
Primary: AstNode = {
    <name:Identifier> => AstNode::标识符表达式(IdentifierExpression {
        name,
        span: Default::default(),
    }),
    Atom,
};

// Atomic expressions - the lowest level
// Struct literals are only allowed here (in parentheses) to avoid ambiguity
Atom: AstNode = {
    BooleanLiteral,
    IntegerLiteral,
    FloatLiteral,
    StringLiteral,
    CharLiteral,
    ArrayLiteral,
    // Parenthesized expressions, including struct literals
    "(" <Expr> ")",
    // Struct literals (must be in safe context or parenthes)
    "(" <name:Identifier> "{" <fields:StructFieldValueList> "}" ")" => AstNode::结构体实例化表达式(StructLiteralExpression {
        struct_name: name,
        fields,
        span: Default::default(),
    }),
    "(" <name:Identifier> "{" "}" ")" => AstNode::结构体实例化表达式(StructLiteralExpression {
        struct_name: name,
        fields: vec![],
        span: Default::default(),
    }),
};



BooleanLiteral: AstNode = {
    "真" => AstNode::字面量表达式(LiteralExpression {
        value: LiteralValue::布尔(true),
        span: Default::default(),
    }),
    "假" => AstNode::字面量表达式(LiteralExpression {
        value: LiteralValue::布尔(false),
        span: Default::default(),
    }),
};

IntegerLiteral: AstNode = {
    <n:r"[0-9]+"> => AstNode::字面量表达式(LiteralExpression {
        value: LiteralValue::整数(n.parse().unwrap()),
        span: Default::default(),
    }),
};

FloatLiteral: AstNode = {
    <n:r"[0-9]+\.[0-9]+"> => AstNode::字面量表达式(LiteralExpression {
        value: LiteralValue::浮点数(n.parse().unwrap()),
        span: Default::default(),
    }),
};

StringLiteral: AstNode = {
    <s:r#""[^"]*""#> => AstNode::字面量表达式(LiteralExpression {
        value: LiteralValue::字符串(s[1..s.len()-1].to_string()),
        span: Default::default(),
    }),
};

CharLiteral: AstNode = {
    <c:r"'.'"> => AstNode::字面量表达式(LiteralExpression {
        value: LiteralValue::字符(c.chars().nth(1).unwrap()),
        span: Default::default(),
    }),
};

ArrayLiteral: AstNode = {
    "[" <elements:ExprList> "]" => AstNode::数组字面量表达式(ArrayLiteralExpression {
        elements,
        span: Default::default(),
    }),
    "[" "]" => AstNode::数组字面量表达式(ArrayLiteralExpression {
        elements: vec![],
        span: Default::default(),
    }),
};


StructFieldValueList: Vec<StructFieldValue> = {
    <fields:Comma<StructFieldValue>> => fields,
};

StructFieldValue: StructFieldValue = {
    <name:Identifier> ":" <value:Expr> => StructFieldValue {
        name,
        value: Box::new(value),
        span: Default::default(),
    },
};

ParameterList: Vec<Parameter> = {
    <params:Comma<Parameter>> => params,
};

Parameter: Parameter = {
    // Fix syntax - use proper colon token
    <name:Identifier> ":" <type_annotation:Type> => Parameter {
        name,
        type_annotation: Some(type_annotation),
        span: Default::default(),
    },
    <name:Identifier> => Parameter {
        name,
        type_annotation: None,
        span: Default::default(),
    },
};

// Helper macro for comma-separated lists
Comma<T>: Vec<T> = {
    <first:T> => vec![first],
    <first:T> "," <rest:Comma<T>> => {
        let mut rest = rest;
        rest.insert(0, first);
        rest
    },
};

// Helper macro for semicolon-separated lists
SemiSeparated<T>: Vec<T> = {
    <first:T> ";" => vec![first],
    <first:T> ";" <rest:SemiSeparated<T>> => {
        let mut rest = rest;
        rest.insert(0, first);
        rest
    }
};

ExprList: Vec<AstNode> = {
    <exprs:Comma<Expr>> => exprs,
};

Type: TypeNode = {
    // 容器类型 - 使用特殊语法避免冲突
    "数组" "<" <element_type:Type> ">" => TypeNode::数组类型(ArrayType {
        element_type: Box::new(element_type),
        size: None,
    }),
    "字典" "<" <key_type:Type> "," <value_type:Type> ">" => TypeNode::字典类型(DictionaryType {
        key_type: Box::new(key_type),
        value_type: Box::new(value_type),
    }),
    "列表" "<" <element_type:Type> ">" => TypeNode::列表类型(ListType {
        element_type: Box::new(element_type),
    }),
    "集合" "<" <element_type:Type> ">" => TypeNode::集合类型(SetType {
        element_type: Box::new(element_type),
    }),

    // 指针和引用类型
    "指针" "<" <target_type:Type> ">" => TypeNode::指针类型(PointerType {
        target_type: Box::new(target_type),
    }),
    "引用" "<" <target_type:Type> ">" => TypeNode::引用类型(ReferenceType {
        target_type: Box::new(target_type),
        is_mutable: false,
    }),
    "可变引用" "<" <target_type:Type> ">" => TypeNode::引用类型(ReferenceType {
        target_type: Box::new(target_type),
        is_mutable: true,
    }),

    // 基础类型 - 使用关键字而不是标识符
    BasicTypeKeyword,

    // 自定义类型 (struct names, etc.) - 使用TypeName避免冲突
    <name:TypeName> => TypeNode::自定义类型(name),
};

// 用于类型名称的标识符，避免与其他Identifier冲突
TypeName: String = {
    <id:r"[a-zA-Z_][a-zA-Z0-9_]*"> => id.to_string(),
    <id:r"[\u4e00-\u9fff][\u4e00-\u9fffa-zA-Z0-9_]*"> => {
        // Simplified check - use individual checks to avoid long match patterns
        if id == "变量" || id == "常量" || id == "函数" || id == "异步" || id == "返回" ||
           id == "如果" || id == "否则" || id == "当" || id == "对于" || id == "在" || id == "真" || id == "假" ||
           id == "等待" || id == "循环" || id == "包" || id == "导入" || id == "导出" || id == "作为" ||
           id == "公开" || id == "私有" || id == "模块" || id == "自己" ||
           id == "枚举" || id == "实现" || id == "特性" {
            panic!("Keyword used as type name: {}", id);
        }
        id.to_string()
    }
};

// 基础类型关键字解析
BasicTypeKeyword: TypeNode = {
    "整数" => TypeNode::基础类型(BasicType::整数),
    "长整数" => TypeNode::基础类型(BasicType::长整数),
    "短整数" => TypeNode::基础类型(BasicType::短整数),
    "字节" => TypeNode::基础类型(BasicType::字节),
    "浮点数" => TypeNode::基础类型(BasicType::浮点数),
    "布尔" => TypeNode::基础类型(BasicType::布尔),
    "字符" => TypeNode::基础类型(BasicType::字符),
    "字符串" => TypeNode::基础类型(BasicType::字符串),
    "空" => TypeNode::基础类型(BasicType::空),
};

Identifier: String = {
    <id:r"[a-zA-Z_][a-zA-Z0-9_]*"> => id.to_string(),
    <id:r"[\u4e00-\u9fff][\u4e00-\u9fffa-zA-Z0-9_]*"> => {
        // Check if it's a forbidden keyword using individual checks
        // Note: 自身, 自己, 自我 are allowed as they are used for method receivers
        if id == "变量" || id == "常量" || id == "函数" || id == "异步" || id == "返回" ||
           id == "如果" || id == "否则" || id == "当" || id == "对于" || id == "在" || id == "真" || id == "假" ||
           id == "等待" || id == "循环" || id == "中断" || id == "继续" || id == "匹配" || id == "跳转" ||
           id == "抛出" || id == "捕获" || id == "尝试" || id == "选项" ||
           id == "拥有" || id == "借用" || id == "移动" || id == "克隆" || id == "释放" || id == "新建" ||
           id == "并行" || id == "并发" || id == "任务" || id == "启动" || id == "线程" || id == "锁" || id == "原子" ||
           id == "长度" || id == "包含" || id == "输入" || id == "包" || id == "导入" ||
           id == "导出" || id == "作为" || id == "公开" || id == "私有" || id == "模块" ||
           id == "方法" || id == "枚举" ||
           id == "联合体" || id == "实现" || id == "特性" || id == "主程序入口" {
            panic!("Keyword used as identifier: {}", id);
        }
        id.to_string()
    },
};

// 方法接收者标识符 - 允许使用 "自身"、"自己" 等关键字
ReceiverIdentifier: String = {
    <id:r"[a-zA-Z_][a-zA-Z0-9_]*"> => id.to_string(),
    <id:r"[\u4e00-\u9fff][\u4e00-\u9fffa-zA-Z0-9_]*"> => {
        // Allow 自身, 自己, 自我 as receiver names
        // Still forbid other keywords
        if id == "变量" || id == "常量" || id == "函数" || id == "异步" || id == "返回" ||
           id == "如果" || id == "否则" || id == "当" || id == "对于" || id == "在" || id == "真" || id == "假" ||
           id == "等待" || id == "循环" || id == "中断" || id == "继续" || id == "匹配" || id == "跳转" ||
           id == "抛出" || id == "捕获" || id == "尝试" || id == "选项" ||
           id == "拥有" || id == "借用" || id == "移动" || id == "克隆" || id == "释放" || id == "新建" ||
           id == "并行" || id == "并发" || id == "任务" || id == "启动" || id == "线程" || id == "锁" || id == "原子" ||
           id == "长度" || id == "包含" || id == "输入" || id == "包" || id == "导入" ||
           id == "导出" || id == "作为" || id == "公开" || id == "私有" || id == "模块" ||
           id == "方法" || id == "枚举" ||
           id == "联合体" || id == "实现" || id == "特性" || id == "主程序入口" {
            panic!("Keyword used as receiver identifier: {}", id);
        }
        id.to_string()
    },
};

IdentifierExpression: AstNode = {
    <name:Identifier> => AstNode::标识符表达式(IdentifierExpression {
        name,
        span: Default::default(),
    }),
};
