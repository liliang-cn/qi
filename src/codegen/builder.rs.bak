//! IR builder for Qi language

use crate::parser::ast::{AstNode, BinaryOperator};

/// IR instruction
#[derive(Debug, Clone)]
#[allow(dead_code)]
pub enum IrInstruction {
    /// Allocate a variable
    分配 {
        dest: String,
        type_name: String,
    },

    /// Store a value
    存储 {
        target: String,
        value: String,
    },

    /// Load a value
    加载 {
        dest: String,
        source: String,
    },

    /// Binary operation
    二元操作 {
        dest: String,
        left: String,
        operator: BinaryOperator,
        right: String,
    },

    /// Function call
    函数调用 {
        dest: Option<String>,
        callee: String,
        arguments: Vec<String>,
    },

    /// Return from function
    返回 {
        value: Option<String>,
    },

    /// Jump to label
    跳转 {
        label: String,
    },

    /// Conditional jump
    条件跳转 {
        condition: String,
        true_label: String,
        false_label: String,
    },

    /// Label
    标签 {
        name: String,
    },

    /// Array access (getelementptr)
    数组访问 {
        dest: String,
        array: String,
        index: String,
    },

    /// Array allocation
    数组分配 {
        dest: String,
        size: String,
    },

    /// Array store
    数组存储 {
        array: String,
        index: String,
        value: String,
    },

    /// String concatenation
    字符串连接 {
        dest: String,
        left: String,
        right: String,
    },
}

/// IR builder
pub struct IrBuilder {
    instructions: Vec<IrInstruction>,
    temp_counter: usize,
    label_counter: usize,
}

impl IrBuilder {
    pub fn new() -> Self {
        Self {
            instructions: Vec::new(),
            temp_counter: 0,
            label_counter: 0,
        }
    }

    pub fn build(&mut self, ast: &AstNode) -> Result<String, String> {
        self.instructions.clear();
        self.temp_counter = 0;
        self.label_counter = 0;

        self.build_node(ast)?;
        self.emit_llvm_ir()
    }

    #[allow(dead_code)]
    fn generate_temp(&mut self) -> String {
        self.temp_counter += 1;
        format!("%t{}", self.temp_counter)
    }

    #[allow(dead_code)]
    fn generate_label(&mut self) -> String {
        self.label_counter += 1;
        format!("L{}", self.label_counter)
    }

    #[allow(dead_code)]
    fn add_instruction(&mut self, instruction: IrInstruction) {
        self.instructions.push(instruction);
    }

    pub fn get_instructions(&self) -> &[IrInstruction] {
        &self.instructions
    }

    pub fn clear(&mut self) {
        self.instructions.clear();
        self.temp_counter = 0;
        self.label_counter = 0;
    }

    /// Build IR for an AST node
    fn build_node(&mut self, node: &AstNode) -> Result<String, String> {
        match node {
            AstNode::程序(program) => {
                for stmt in &program.statements {
                    self.build_node(stmt)?;
                }
                Ok("main".to_string())
            }
            AstNode::变量声明(decl) => {
                let var_name = &decl.name;
                let type_name = self.get_llvm_type(&decl.type_annotation);

                // Allocate variable
                self.add_instruction(IrInstruction::分配 {
                    dest: var_name.clone(),
                    type_name,
                });

                // Initialize if there's an initializer
                if let Some(initializer) = &decl.initializer {
                    let value = self.build_node(initializer)?;
                    self.add_instruction(IrInstruction::存储 {
                        target: var_name.clone(),
                        value,
                    });
                }

                Ok(var_name.clone())
            }
            AstNode::函数声明(func_decl) => {
                let func_name = &func_decl.name;

                // Build parameter list
                let params: Vec<String> = func_decl.parameters
                    .iter()
                    .map(|p| {
                        let type_str = self.get_llvm_type(&Some(p.type_annotation.clone()));
                        format!("{} {}", type_str, p.name)
                    })
                    .collect();

                let params_str = if params.is_empty() {
                    String::new()
                } else {
                    format!(" {}", params.join(", "))
                };

                // Add function label
                self.add_instruction(IrInstruction::标签 {
                    name: format!("define {} @{}({}) {{", self.get_return_type(&func_decl.return_type), func_name, params_str),
                });

                // Process function body
                for stmt in &func_decl.body {
                    self.build_node(stmt)?;
                }

                // Close function
                self.add_instruction(IrInstruction::标签 {
                    name: "}".to_string(),
                });

                Ok(func_name.clone())
            }
            AstNode::返回语句(return_stmt) => {
                let value = if let Some(expr) = &return_stmt.value {
                    Some(self.build_node(expr)?)
                } else {
                    None
                };

                self.add_instruction(IrInstruction::返回 { value });
                Ok("ret".to_string())
            }
            AstNode::表达式语句(expr_stmt) => {
                self.build_node(&expr_stmt.expression)
            }
            AstNode::如果语句(if_stmt) => {
                // Build condition
                let condition = self.build_node(&if_stmt.condition)?;

                // Generate labels
                let then_label = self.generate_label();
                let else_label = self.generate_label();
                let end_label = self.generate_label();

                // Compare condition to 0 (false)
                let temp = self.generate_temp();
                self.add_instruction(IrInstruction::二元操作 {
                    dest: temp.clone(),
                    left: condition,
                    operator: crate::parser::ast::BinaryOperator::不等于,
                    right: "0".to_string(),
                });

                // Conditional jump
                self.add_instruction(IrInstruction::条件跳转 {
                    condition: temp,
                    true_label: then_label.clone(),
                    false_label: else_label.clone(),
                });

                // Then branch
                self.add_instruction(IrInstruction::标签 { name: then_label.clone() });
                for stmt in &if_stmt.then_branch {
                    self.build_node(stmt)?;
                }
                self.add_instruction(IrInstruction::跳转 { label: end_label.clone() });

                // Else branch (if exists)
                self.add_instruction(IrInstruction::标签 { name: else_label.clone() });
                if let Some(else_branch) = &if_stmt.else_branch {
                    for stmt in else_branch {
                        self.build_node(stmt)?;
                    }
                }

                // End label
                self.add_instruction(IrInstruction::标签 { name: end_label.clone() });

                Ok("if".to_string())
            }
            AstNode::当语句(while_stmt) => {
                // Generate labels
                let start_label = self.generate_label();
                let body_label = self.generate_label();
                let end_label = self.generate_label();

                // Start label
                self.add_instruction(IrInstruction::标签 { name: start_label.clone() });

                // Build condition
                let condition = self.build_node(&while_stmt.condition)?;

                // Compare condition to 0 (false)
                let temp = self.generate_temp();
                self.add_instruction(IrInstruction::二元操作 {
                    dest: temp.clone(),
                    left: condition,
                    operator: crate::parser::ast::BinaryOperator::不等于,
                    right: "0".to_string(),
                });

                // Conditional jump to body
                self.add_instruction(IrInstruction::条件跳转 {
                    condition: temp,
                    true_label: body_label.clone(),
                    false_label: end_label.clone(),
                });

                // Body
                self.add_instruction(IrInstruction::标签 { name: body_label.clone() });
                for stmt in &while_stmt.body {
                    self.build_node(stmt)?;
                }

                // Jump back to start
                self.add_instruction(IrInstruction::跳转 { label: start_label.clone() });

                // End label
                self.add_instruction(IrInstruction::标签 { name: end_label.clone() });

                Ok("while".to_string())
            }
            AstNode::循环语句(loop_stmt) => {
                // Generate labels
                let start_label = self.generate_label();
                let end_label = self.generate_label();

                // Start label
                self.add_instruction(IrInstruction::标签 { name: start_label.clone() });

                // Body
                for stmt in &loop_stmt.body {
                    self.build_node(stmt)?;
                }

                // Jump back to start (infinite loop)
                self.add_instruction(IrInstruction::跳转 { label: start_label.clone() });

                // End label (unreachable in current implementation)
                self.add_instruction(IrInstruction::标签 { name: end_label.clone() });

                Ok("loop".to_string())
            }
            AstNode::对于语句(_for_stmt) => {
                // For loops are more complex, skip for now
                Ok("for".to_string())
            }
            AstNode::字面量表达式(literal) => {
                match &literal.value {
                    crate::parser::ast::LiteralValue::整数(n) => Ok(n.to_string()),
                    crate::parser::ast::LiteralValue::浮点数(f) => Ok(f.to_string()),
                    crate::parser::ast::LiteralValue::布尔(b) => Ok(if *b { "1".to_string() } else { "0".to_string() }),
                    crate::parser::ast::LiteralValue::字符串(s) => Ok(format!("\"{}\"", s)),
                }
            }
            AstNode::二元操作表达式(binary_expr) => {
                let left = self.build_node(&binary_expr.left)?;
                let right = self.build_node(&binary_expr.right)?;

                let temp = self.generate_temp();
                self.add_instruction(IrInstruction::二元操作 {
                    dest: temp.clone(),
                    left,
                    operator: binary_expr.operator,
                    right,
                });
                Ok(temp)
            }
            AstNode::赋值表达式(assign_expr) => {
                let value = self.build_node(&assign_expr.value)?;

                // For assignment, we store the value to the variable
                self.add_instruction(IrInstruction::存储 {
                    target: assign_expr.target.clone(),
                    value,
                });
                Ok(assign_expr.target.clone())
            }
            AstNode::函数调用表达式(call_expr) => {
                // Evaluate arguments
                let mut arg_temps = Vec::new();
                for arg in &call_expr.arguments {
                    let temp = self.build_node(arg)?;
                    arg_temps.push(temp);
                }

                // Generate function call
                let temp = self.generate_temp();
                self.add_instruction(IrInstruction::函数调用 {
                    dest: Some(temp.clone()),
                    callee: call_expr.callee.clone(),
                    arguments: arg_temps,
                });
                Ok(temp)
            }
            AstNode::标识符表达式(ident) => {
                let temp = self.generate_temp();
                self.add_instruction(IrInstruction::加载 {
                    dest: temp.clone(),
                    source: ident.name.clone(),
                });
                Ok(temp)
            }
            AstNode::数组访问表达式(array_access) => {
                // Build array expression
                let array_var = self.build_node(&array_access.array)?;

                // Build index expression
                let index_var = self.build_node(&array_access.index)?;

                // Generate getelementptr instruction
                let temp = self.generate_temp();
                self.add_instruction(IrInstruction::数组访问 {
                    dest: temp.clone(),
                    array: array_var,
                    index: index_var,
                });
                Ok(temp)
            }
            AstNode::数组字面量表达式(array_literal) => {
                // For now, create a simple array literal
                // In a real implementation, this would allocate memory and store elements
                let temp = self.generate_temp();

                // Create array allocation
                let size = array_literal.elements.len();
                self.add_instruction(IrInstruction::数组分配 {
                    dest: temp.clone(),
                    size: size.to_string(),
                });

                // Store each element (simplified)
                for (i, element) in array_literal.elements.iter().enumerate() {
                    let element_var = self.build_node(element)?;
                    self.add_instruction(IrInstruction::数组存储 {
                        array: temp.clone(),
                        index: i.to_string(),
                        value: element_var,
                    });
                }

                Ok(temp)
            }
            AstNode::字符串连接表达式(string_concat) => {
                // Build left and right expressions
                let left_var = self.build_node(&string_concat.left)?;
                let right_var = self.build_node(&string_concat.right)?;

                // Generate string concatenation
                let temp = self.generate_temp();
                self.add_instruction(IrInstruction::字符串连接 {
                    dest: temp.clone(),
                    left: left_var,
                    right: right_var,
                });
                Ok(temp)
            }
            _ => {
                Err(format!("Unsupported AST node: {:?}", node))
            }
        }
    }

    /// Get LLVM type string from type annotation
    fn get_llvm_type(&self, type_annotation: &Option<crate::parser::ast::TypeNode>) -> String {
        match type_annotation {
            Some(crate::parser::ast::TypeNode::基础类型(basic_type)) => {
                match basic_type {
                    crate::parser::ast::BasicType::整数 => "i64".to_string(),
                    crate::parser::ast::BasicType::浮点数 => "double".to_string(),
                    crate::parser::ast::BasicType::布尔 => "i1".to_string(),
                    crate::parser::ast::BasicType::字符串 => "i8*".to_string(),
                    crate::parser::ast::BasicType::字符 => "i8".to_string(),
                    crate::parser::ast::BasicType::空 => "void".to_string(),
                }
            }
            _ => "i64".to_string(), // Default to i64
        }
    }

    /// Get return type for function
    fn get_return_type(&self, return_type: &Option<crate::parser::ast::TypeNode>) -> String {
        self.get_llvm_type(return_type)
    }

    /// Emit LLVM IR from instructions
    fn emit_llvm_ir(&self) -> Result<String, String> {
        let mut ir = String::new();

        // Add module header
        ir.push_str("; Generated by Qi Language Compiler\n");
        ir.push_str("; Module ID = 'qi_program'\n\n");

        // Add external function declarations
        ir.push_str("declare i32 @printf(i8*, ...)\n");
        ir.push_str("declare i8* @qi_string_concat(i8*, i8*)\n\n");

        // Process instructions
        for instruction in &self.instructions {
            match instruction {
                IrInstruction::分配 { dest, type_name } => {
                    ir.push_str(&format!("{} = alloca {}\n", dest, type_name));
                }
                IrInstruction::存储 { target, value } => {
                    let (value_type, pointer_type) = if value.starts_with('"') {
                        ("i8*", "i8**")
                    } else if value.contains('.') {
                        ("double", "double*")
                    } else if value == "0" || value == "1" {
                        ("i1", "i1*")
                    } else {
                        ("i64", "i64*")
                    };
                    ir.push_str(&format!("store {} {}, {} {}\n", value_type, value, pointer_type, target));
                }
                IrInstruction::加载 { dest, source } => {
                    ir.push_str(&format!("{} = load i64, i64* {}\n", dest, source));
                }
                IrInstruction::二元操作 { dest, left, operator, right } => {
                    let op_str = match operator {
                        crate::parser::ast::BinaryOperator::加 => "add",
                        crate::parser::ast::BinaryOperator::减 => "sub",
                        crate::parser::ast::BinaryOperator::乘 => "mul",
                        crate::parser::ast::BinaryOperator::除 => "sdiv",
                        crate::parser::ast::BinaryOperator::取余 => "srem",
                        crate::parser::ast::BinaryOperator::等于 => "icmp eq",
                        crate::parser::ast::BinaryOperator::不等于 => "icmp ne",
                        crate::parser::ast::BinaryOperator::大于 => "icmp sgt",
                        crate::parser::ast::BinaryOperator::小于 => "icmp slt",
                        crate::parser::ast::BinaryOperator::大于等于 => "icmp sge",
                        crate::parser::ast::BinaryOperator::小于等于 => "icmp sle",
                        _ => return Err(format!("Unsupported binary operator: {:?}", operator)),
                    };

                    if matches!(operator,
                        crate::parser::ast::BinaryOperator::等于 |
                        crate::parser::ast::BinaryOperator::不等于 |
                        crate::parser::ast::BinaryOperator::大于 |
                        crate::parser::ast::BinaryOperator::小于 |
                        crate::parser::ast::BinaryOperator::大于等于 |
                        crate::parser::ast::BinaryOperator::小于等于
                    ) {
                        // Comparison operations return i1 (boolean)
                        ir.push_str(&format!("{} = {} i1 {}, {}\n", dest, op_str, left, right));
                    } else {
                        // Arithmetic operations
                        ir.push_str(&format!("{} = {} i64 {}, {}\n", dest, op_str, left, right));
                    }
                }
                IrInstruction::函数调用 { dest, callee, arguments } => {
                    let args_str = if arguments.is_empty() {
                        String::new()
                    } else {
                        format!(" {}", arguments.join(", "))
                    };

                    match dest {
                        Some(dest_var) => {
                            ir.push_str(&format!("{} = call i64 @{}({})\n", dest_var, callee, args_str));
                        }
                        None => {
                            ir.push_str(&format!("call void @{}({})\n", callee, args_str));
                        }
                    }
                }
                IrInstruction::返回 { value: None } => {
                    ir.push_str("ret void\n");
                }
                IrInstruction::返回 { value: Some(val) } => {
                    ir.push_str(&format!("ret i64 {}\n", val));
                }
                IrInstruction::标签 { name } => {
                    if name.starts_with("define") {
                        ir.push_str(&format!("{}\n", name));
                    } else if name == "}" {
                        ir.push_str("}\n\n");
                    } else {
                        ir.push_str(&format!("{}:\n", name));
                    }
                }
                IrInstruction::跳转 { label } => {
                    ir.push_str(&format!("br label %{}\n", label));
                }
                IrInstruction::条件跳转 { condition, true_label, false_label } => {
                    ir.push_str(&format!("br i1 {}, label %{}, label %{}\n", condition, true_label, false_label));
                }
                IrInstruction::数组访问 { dest, array, index } => {
                    // Simplified array access using getelementptr
                    ir.push_str(&format!("{} = getelementptr [10 x i64], [10 x i64]* {}, i64 0, i64 {}\n", dest, array, index));
                }
                IrInstruction::数组分配 { dest, size } => {
                    // Simplified array allocation
                    ir.push_str(&format!("{} = alloca [{} x i64]\n", dest, size));
                }
                IrInstruction::数组存储 { array, index, value } => {
                    // Simplified array store
                    ir.push_str(&format!("store i64 {}, i64* getelementptr [10 x i64], [10 x i64]* {}, i64 0, i64 {}\n", value, array, index));
                }
                IrInstruction::字符串连接 { dest, left, right } => {
                    // Simplified string concatenation using external function
                    ir.push_str(&format!("{} = call i8* @qi_string_concat(i8* {}, i8*)\n", dest, left, right));
                }
            }
        }

        Ok(ir)
    }
}

impl Default for IrBuilder {
    fn default() -> Self {
        Self::new()
    }
}