// 复杂嵌套控制流测试用例 | Complex Nested Control Flow Test Cases
// 测试多层嵌套的控制流结构 | Testing deeply nested control flow structures

// 测试1: 三层嵌套如果语句 | Test 1: Triple Nested If Statements
函数 复杂条件判断(a, b, c) {
    如果 (a > 0) {
        如果 (b > 0) {
            如果 (c > 0) {
                返回 "全部为正";
            } 否则 {
                返回 "a和b为正，c为负";
            }
        } 否则 {
            如果 (c > 0) {
                返回 "a和c为正，b为负";
            } 否则 {
                返回 "a为正，b和c为负";
            }
        }
    } 否则 {
        如果 (b > 0) {
            如果 (c > 0) {
                返回 "b和c为正，a为负";
            } 否则 {
                返回 "b为正，a和c为负";
            }
        } 否则 {
            如果 (c > 0) {
                返回 "c为正，a和b为负";
            } 否则 {
                返回 "全部为负";
            }
        }
    }
}

// 测试2: 如果语句和循环的嵌套 | Test 2: If-Statement and Loop Nesting
函数 在范围内查找数字(数字列表, 最小值, 最大值) {
    变量 结果列表 = [];
    变量 索引 = 0;

    当 (索引 < 获取数组长度(数字列表)) {
        变量 当前数字 = 数字列表[索引];

        如果 (当前数字 >= 最小值 与 当前数字 <= 最大值) {
            // 嵌套循环验证唯一性
            变量 已经存在 = 假;
            变量 检查索引 = 0;

            当 (检查索引 < 获取数组长度(结果列表) 与 非 已经存在) {
                如果 (结果列表[检查索引] == 当前数字) {
                    已经存在 = 真;
                }
                检查索引 = 检查索引 + 1;
            }

            如果 (非 已经存在) {
                添加到数组(结果列表, 当前数字);
            }
        }

        索引 = 索引 + 1;
    }

    返回 结果列表;
}

// 测试3: 多重嵌套循环 | Test 3: Multiple Nested Loops
function 生成三维矩阵(x, y, z) {
    变量 矩阵 = [];
    变量 i = 0;

    当 (i < x) {
        矩阵[i] = [];
        变量 j = 0;

        当 (j < y) {
            矩阵[i][j] = [];
            变量 k = 0;

            对于 (k = 0; k < z; k = k + 1) {
                // 复杂的计算逻辑
                变量 值;

                如果 (i == j 与 j == k) {
                    值 = 1; // 对角线元素
                } 否则 如果 (i + j + k % 2 == 0) {
                    值 = 2; // 偶数位置
                } 否则 {
                    值 = 0; // 其他位置
                }

                矩阵[i][j][k] = 值;
            }

            j = j + 1;
        }

        i = i + 1;
    }

    返回 矩阵;
}

// 测试4: 循环中的复杂条件链 | Test 4: Complex Condition Chain in Loop
function 复杂数据处理(数据) {
    变量 结果 = [];
    变量 计数器 = 0;
    变量 总和 = 0;
    变量 最大值 = 最小整数;
    变量 最小值 = 最大整数;
    变量 索引 = 0;

    当 (索引 < 获取数组长度(数据)) {
        变量 项目 = 数据[索引];
        变量 数值 = 项目.值;

        // 复杂的条件判断
        如果 (数值 > 0) {
            如果 (数值 > 最大值) {
                最大值 = 数值;
            }

            如果 (数值 < 最小值 或 最小值 == 最大整数) {
                最小值 = 数值;
            }

            如果 (数值 % 2 == 0) {
                // 嵌套循环处理偶数
                变量 因数计数 = 0;
                变量 除数 = 1;

                对于 (除数 = 1; 除数 <= 数值 / 2; 除数 = 除数 + 1) {
                    如果 (数值 % 除数 == 0) {
                        因数计数 = 因数计数 + 1;
                    }
                }

                项目.类型 = "偶数";
                项目.因数个数 = 因数计数;
            } 否则 {
                项目.类型 = "奇数";

                // 检查是否为质数
                变量 是质数 = 真;
                变量 检查除数 = 3;

                当 (检查除数 * 检查除数 <= 数值 与 是质数) {
                    如果 (数值 % 检查除数 == 0) {
                        是质数 = 假;
                    }
                    检查除数 = 检查除数 + 2;
                }

                项目.是质数 = 是质数;
            }

            总和 = 总和 + 数值;
            计数器 = 计数器 + 1;
            添加到数组(结果, 项目);
        }

        索引 = 索引 + 1;
    }

    返回 {
        处理后的数据: 结果,
        统计: {
            总和: 总和,
            平均值: 总和 / 计数器,
            最大值: 最大值,
            最小值: 最小值,
            计数: 计数器
        }
    };
}

// 测试5: 状态机和嵌套控制流 | Test 5: State Machine with Nested Control Flow
function 复杂状态机(输入) {
    变量 状态 = "开始";
    变量 输出 = [];
    变量 当前位置 = 0;

    当 (当前位置 < 获取数组长度(输入) 与 状态 != "错误" 与 状态 != "完成") {
        变量 符号 = 输入[当前位置];

        如果 (状态 == "开始") {
            如果 (符号 == 'a' 或 符号 == 'b' 或 符号 == 'c') {
                状态 = "状态1";
                添加到数组(输出, "识别到字母: " + 符号);
            } 否则 如果 (符号 == '1' 或 符号 == '2' 或 符号 == '3') {
                状态 = "状态2";
                添加到数组(输出, "识别到数字: " + 符号);
            } 否则 {
                状态 = "错误";
                添加到数组(输出, "无效的起始符号: " + 符号);
            }
        } 否则 如果 (状态 == "状态1") {
            如果 (符号 >= '0' 与 符号 <= '9') {
                状态 = "状态3";
                添加到数组(输出, "字母后跟数字");
            } 否则 如果 (符号 == 'a' 或 符号 == 'b' 或 符号 == 'c') {
                // 保持状态1
                添加到数组(输出, "连续字母");
            } 否则 {
                状态 = "错误";
                添加到数组(输出, "状态1中的无效符号");
            }
        } 否则 如果 (状态 == "状态2") {
            如果 (符号 == 'a' 或 符号 == 'b' 或 符号 == 'c') {
                状态 = "状态4";
                添加到数组(输出, "数字后跟字母");
            } 否则 如果 (符号 >= '0' 与 符号 <= '9') {
                // 保持状态2
                添加到数组(输出, "连续数字");
            } 否则 {
                状态 = "错误";
                添加到数组(输出, "状态2中的无效符号");
            }
        } 否则 如果 (状态 == "状态3") {
            // 嵌套循环处理数字序列
            变量 数字结束 = 假;
            变量 数字计数 = 1;

            当 (当前位置 + 数字计数 < 获取数组长度(输入) 与 非 数字结束) {
                变量 下一个符号 = 输入[当前位置 + 数字计数];

                如果 (下一个符号 >= '0' 与 下一个符号 <= '9') {
                    数字计数 = 数字计数 + 1;
                } 否则 {
                    数字结束 = 真;

                    如果 (下一个符号 == 'a' 或 下一个符号 == 'b' 或 下一个符号 == 'c') {
                        状态 = "状态4";
                        添加到数组(输出, "数字序列后跟字母");
                    } 否则 如果 (下一个符号 == '#') {
                        状态 = "完成";
                        添加到数组(输出, "找到结束符");
                    } 否则 {
                        状态 = "错误";
                        添加到数组(输出, "数字序列后的无效符号");
                    }
                }
            }

            如果 (数字结束) {
                当前位置 = 当前位置 + 数字计数 - 1;
            }
        } 否则 如果 (状态 == "状态4") {
            如果 (符号 == '#') {
                状态 = "完成";
                添加到数组(输出, "正常结束");
            } 否则 {
                状态 = "错误";
                添加到数组(输出, "状态4中的无效结束");
            }
        }

        当前位置 = 当前位置 + 1;
    }

    如果 (状态 != "完成" 与 状态 != "错误") {
        添加到数组(输出, "意外结束输入");
    }

    返回 输出;
}

// 测试6: 递归和迭代的组合 | Test 6: Combination of Recursion and Iteration
function 复杂递归迭代(n, 深度) {
    如果 (深度 <= 0 或 n <= 1) {
        返回 n;
    }

    变量 结果 = n;
    变量 i = 1;

    对于 (i = 1; i < 深度; i = i + 1) {
        如果 (i % 2 == 0) {
            // 偶数迭代：使用加法
            结果 = 结果 + 复杂递归迭代(n / i, i);
        } 否则 {
            // 奇数迭代：使用乘法
            变量 临时结果 = 1;
            变量 j = 0;

            当 (j < i) {
                如果 (j % 3 == 0) {
                    临时结果 = 临时结果 * (n - j);
                } 否则 {
                    临时结果 = 临时结果 + (n + j);
                }
                j = j + 1;
            }

            结果 = 结果 + 临时结果;
        }
    }

    返回 结果;
}

// 测试7: 复杂的搜索算法 | Test 7: Complex Search Algorithm
function 复杂搜索(矩阵, 目标值) {
    变量 行数 = 获取数组长度(矩阵);
    变量 列数 = 获取数组长度(矩阵[0]);
    变量 结果位置 = {行: -1, 列: -1};
    变量 找到 = 假;
    变量 当前行 = 0;

    当 (当前行 < 行数 与 非 找到) {
        变量 当前列 = 0;

        // 优先搜索对角线
        如果 (当前行 < 列数) {
            如果 (矩阵[当前行][当前行] == 目标值) {
                结果位置 = {行: 当前行, 列: 当前行};
                找到 = 真;
            }
        }

        // 如果没在对角线找到，搜索整行
        当 (当前列 < 列数 与 非 找到) {
            变量 当前值 = 矩阵[当前行][当前列];

            如果 (当前值 == 目标值) {
                结果位置 = {行: 当前行, 列: 当前列};
                找到 = 真;
            } 否则 {
                // 检查周围的值（如果有）
                变量 搜索范围 = 1;

                对于 (搜索范围 = 1; 搜索范围 <= 2; 搜索范围 = 搜索范围 + 1) {
                    // 检查上方
                    如果 (当前行 - 搜索范围 >= 0) {
                        如果 (矩阵[当前行 - 搜索范围][当前列] == 目标值) {
                            结果位置 = {行: 当前行 - 搜索范围, 列: 当前列};
                            找到 = 真;
                            跳出循环; // 这里需要break，但Qi语言可能还没有实现
                        }
                    }

                    // 检查下方
                    如果 (当前行 + 搜索范围 < 行数) {
                        如果 (矩阵[当前行 + 搜索范围][当前列] == 目标值) {
                            结果位置 = {行: 当前行 + 搜索范围, 列: 当前列};
                            找到 = 真;
                            跳出循环;
                        }
                    }

                    // 检查左侧
                    如果 (当前列 - 搜索范围 >= 0) {
                        如果 (矩阵[当前行][当前列 - 搜索范围] == 目标值) {
                            结果位置 = {行: 当前行, 列: 当前列 - 搜索范围};
                            找到 = 真;
                            跳出循环;
                        }
                    }

                    // 检查右侧
                    如果 (当前列 + 搜索范围 < 列数) {
                        如果 (矩阵[当前行][当前列 + 搜索范围] == 目标值) {
                            结果位置 = {行: 当前行, 列: 当前列 + 搜索范围};
                            找到 = 真;
                            跳出循环;
                        }
                    }
                }
            }

            当前列 = 当前列 + 1;
        }

        当前行 = 当前行 + 1;
    }

    返回 结果位置;
}