# Qi 语言架构设计文档

## 概述

Qi 语言是一个基于中文关键字的静态类型编译型编程语言，采用现代编译器架构，实现高性能与内存安全并重的系统编程能力。

## 整体架构

```
┌─────────────────────────────────────┐
│           Qi 源代码 (.qi)           │
├─────────────────────────────────────┤
│         Rust 编译器前端              │
│  ┌─────────────┬─────────────────┐   │
│  │  词法分析器  │    语法分析器    │   │
│  │  (Pest)     │    (AST)        │   │
│  └─────────────┴─────────────────┘   │
├─────────────────────────────────────┤
│         Rust 编译器中端              │
│  ┌─────────────┬─────────────────┐   │
│  │   语义分析   │    中间代码生成  │   │
│  │(所有权检查)  │     (IR Gen)    │   │
│  └─────────────┴─────────────────┘   │
├─────────────────────────────────────┤
│         Rust 编译器后端 (LLVM)       │
│  ┌─────────────┬─────────────────┐   │
│  │  LLVM IR 生成 │   LLVM 优化器   │   │
│  │  (inkwell)  │   (Optimizer)   │   │
│  └─────────────┴─────────────────┘   │
├─────────────────────────────────────┤
│          Rust 运行时 (Qi-Runtime)   │
│  ┌─────────────┬─────────────────┐   │
│  │  内存分配器  │    并发调度器    │   │
│  │ (Allocator) │ (M:N, Async)    │   │
│  └─────────────┴─────────────────┘   │
├─────────────────────────────────────┤
│       C 系統調用接口 (平台抽象层)    │
│    (平台抽象层 - 见第 5 节)        │
├─────────────────────────────────────┤
│        目标平台 (通过 LLVM 支持)      │
│  ┌─────────┬─────────┬─────────┐   │
│  │  Windows │  Linux  │  macOS  │   │
│  │ (x86_64)│ (x86_64)│ (ARM64) │   │
│  ├─────────┴─────────┴─────────┤   │
│  │      WASM (WASI)            │   │
│  └─────────────────────────────┘   │
└─────────────────────────────────────┘
```

## 核心组件

### 1. 编译器前端

**技术栈**: Rust + Pest 解析器

**主要职责**:
- **词法分析**: 使用 Pest 解析器处理 UTF-8 中文关键字
- **语法分析**: 构建 AST (抽象语法树)
- **错误恢复**: 提供友好的语法错误提示

**优势**:
- 内置 Unicode 支持，直接处理中文字符
- PEG 文法简洁易读，便于维护
- 无需独立的词法分析器，简化架构

### 2. 编译器中端

**技术栈**: Rust

**主要职责**:
- **语义分析**: 类型检查、作用域分析
- **所有权检查**: 内存安全保证的核心
- **生命周期分析**: 防止悬垂指针
- **IR 生成**: 生成中间表示代码

**关键特性**:
- 编译期内存安全检查
- 零成本抽象
- 显式优于隐式的设计原则

### 3. 编译器后端

**技术栈**: LLVM + inkwell

**主要职责**:
- **LLVM IR 生成**: 将中间表示转换为 LLVM IR
- **代码优化**: 利用 LLVM 优化管道
- **机器码生成**: 针对不同目标平台生成本地代码

**支持平台**:
- Windows (x86_64)
- Linux (x86_64)
- macOS (ARM64, x86_64)
- WebAssembly (WASI)

### 4. 运行时系统

**技术栈**: Rust + C

**核心模块**:
- **内存分配器**: 高效的内存管理
- **并发调度器**: M:N 协程调度
- **平台抽象层**: 跨平台系统调用接口

## 技术选型说明

### 解析器选择: Pest

1. **Unicode 原生支持**: 直接处理中文关键字，无需额外配置
2. **PEG 文法**: 直观的语法定义，易于理解和维护
3. **错误报告**: 提供清晰的解析错误信息
4. **性能**: 足够高效，满足编译器性能要求

### 代码生成: LLVM

1. **优化能力**: 成熟的现代优化器
2. **平台支持**: 广泛的目标平台支持
3. **生态系统**: 丰富的工具链和社区支持
4. **稳定性**: 经过大量项目验证的稳定技术

### 运行时: Rust + C

1. **安全性**: Rust 提供内存安全保证
2. **性能**: 接近 C 语言的运行时性能
3. **跨平台**: C 接口便于平台抽象
4. **生态**: 利用 Rust 生态系统的优势

## 设计原则

### 1. 分层架构
- 每个层次职责明确，接口清晰
- 便于独立开发和测试
- 支持渐进式实现和优化

### 2. 平台抽象
- C 接口作为最小平台抽象层
- 运行时逻辑与具体平台解耦
- 便于新增平台支持

### 3. 模块化设计
- 编译器各组件相对独立
- 支持组件替换和升级
- 便于团队协作开发

### 4. 性能优先
- 编译期优化最大化
- 运行时开销最小化
- 零成本抽象设计

## 项目结构

```
qi/
├── compiler/               # Rust 编译器源码
│   ├── src/
│   │   ├── grammar/        # Pest 语法文件
│   │   ├── parser/         # AST 定义和解析
│   │   ├── semantic/       # 语义分析
│   │   └── codegen/        # 代码生成
│   └── Cargo.toml
├── runtime/                # Rust 运行时
│   ├── src/
│   │   ├── memory/         # 内存分配器
│   │   ├── concurrent/     # 并发调度器
│   │   └── ffi.rs          # C 接口绑定
│   └── Cargo.toml
├── runtime_c_iface/        # C 系统接口
│   ├── include/            # C 头文件
│   ├── src/                # 平台特定实现
│   │   ├── posix/
│   │   ├── windows/
│   │   └── wasm_wasi/
│   └── CMakeLists.txt
├── stdlib/                 # Qi 标准库
├── tools/                  # 工具链
│   ├── qi-lsp/             # 语言服务器
│   └── vscode-qi/          # VS Code 扩展
└── tests/                  # 测试文件
```

## 开发策略

### 阶段一: 核心编译器
- 实现 Pest 解析器
- 构建 AST 和基础语义分析
- 实现简单的代码生成

### 阶段二: 内存安全
- 添加所有权检查
- 实现生命周期分析
- 完善错误处理

### 阶段三: 运行时系统
- 开发 Rust 运行时
- 实现 C 平台抽象层
- 添加并发支持

### 阶段四: 工具链
- 开发 LSP 服务器
- 创建 IDE 插件
- 完善测试和文档

这个架构设计确保了 Qi 语言在实现中文编程易用性的同时，具备现代系统编程语言的性能和安全性。