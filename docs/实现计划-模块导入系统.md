# 模块导入系统实现计划

**PLAN: 2025-01-02-module-import-system**

## 标题
实现 Qi 语言模块化导入系统

## 背景 (Context)
- 当前所有标准库函数（加密、IO等）都是内置的，造成命名空间污染
- 需要区分核心内置函数（打印、打印行）和模块函数（加密函数、文件操作等）
- 已有 `导入` 关键字和基础 ImportStatement AST 节点，但未实现运行时解析

## 目标 (Objectives)
1. **P99 编译时开销 < 50ms**：模块解析应该在编译时完成，零运行时开销
2. **支持命名空间调用**：`加密.MD5哈希("text")` 语法正常工作
3. **兼容性**：内置函数（打印、打印行）保持直接调用
4. **可扩展性**：支持未来添加更多标准库模块

## 非目标 (Non-goals)
- 不实现第三方包管理（留待 v0.2.0）
- 不支持选择性导入 `{ MD5哈希, SHA256哈希 }`（留待 v0.2.0）
- 不改变现有内置函数的行为

## 约束 (Constraints)
1. **向后兼容**：现有使用 `MD5哈希()` 的代码应该能提示需要导入
2. **性能**：不增加运行时开销
3. **中文优先**：所有 API 使用中文
4. **编译时检查**：未导入模块的使用应在编译时报错

## 输入/输出契约 (IO Contract)

### 输入
```qi
导入 标准库.加密;

函数 入口() {
    变量 哈希: 字符串 = 加密.MD5哈希("测试");
    打印行(哈希);  // 内置函数，无需导入
}
```

### 输出
- 编译时：构建模块依赖图，检查函数可用性
- 生成的 LLVM IR：直接调用底层 C FFI 函数（`qi_crypto_md5`）
- 错误处理：未导入模块时编译器报错

### 数据结构

#### ModuleRegistry
```rust
pub struct ModuleRegistry {
    /// 已注册的模块
    modules: HashMap<String, Module>,
}

pub struct Module {
    /// 模块名称（如 "加密"）
    name: String,
    /// 模块中的函数列表
    functions: HashMap<String, ModuleFunction>,
}

pub struct ModuleFunction {
    /// 函数名称（如 "MD5哈希"）
    name: String,
    /// 对应的运行时函数名（如 "qi_crypto_md5"）
    runtime_name: String,
    /// 参数类型
    param_types: Vec<String>,
    /// 返回类型
    return_type: String,
}
```

#### ImportContext
```rust
pub struct ImportContext {
    /// 当前文件已导入的模块
    imported_modules: HashMap<String, String>,  // alias -> module_path
}
```

## 步骤分解 (Step Breakdown)

### Step 1: 创建模块注册系统
**产物**：`src/codegen/module_registry.rs`

功能：
- `ModuleRegistry::new()` - 创建注册表
- `register_stdlib_modules()` - 注册标准库模块
- `get_module()` - 获取模块信息
- `get_function()` - 通过模块.函数名获取函数信息

### Step 2: 扩展 IrBuilder 支持导入上下文
**产物**：修改 `src/codegen/builder.rs`

功能：
- 添加 `imported_modules: HashMap<String, String>` 字段
- `process_import()` - 处理导入语句
- `resolve_namespaced_call()` - 解析 `模块.函数()` 调用
- `check_function_available()` - 编译时检查函数是否可用

### Step 3: 修改函数调用解析逻辑
**产物**：修改 `builder.rs` 中的函数调用处理

功能：
- 检测函数调用是否包含命名空间（`.` 符号）
- 如果是内置函数（打印、打印行），直接映射
- 如果是模块函数，检查是否已导入
- 未导入时产生编译错误

### Step 4: 重构加密模块
**产物**：修改 `get_runtime_function_name()`

功能：
- 移除直接的 MD5哈希、SHA256哈希 等映射
- 改为通过模块注册系统查找
- 保持运行时 C FFI 函数不变（`qi_crypto_md5` 等）

### Step 5: 重构 IO 模块
**产物**：分离内置 IO 和模块 IO

功能：
- 保持 `打印`、`打印行` 为内置（无需导入）
- 新增文件操作需要 `导入 标准库.io;` 后使用

### Step 6: 添加测试用例
**产物**：`examples/module_import/`

测试场景：
- ✅ 导入加密模块并使用
- ✅ 未导入时编译报错
- ✅ 内置函数无需导入
- ✅ 多个模块同时导入

## 边界与失败场景 (Edge & Failure Cases)

1. **未导入模块直接使用**
   ```qi
   // 错误：未导入加密模块
   函数 入口() {
       变量 x = 加密.MD5哈希("test");  // 编译错误
   }
   ```
   预期：编译时报错 "模块 '加密' 未导入，请使用 '导入 标准库.加密;'"

2. **重复导入**
   ```qi
   导入 标准库.加密;
   导入 标准库.加密;  // 警告但不报错
   ```
   预期：编译器警告，但正常工作

3. **模块不存在**
   ```qi
   导入 标准库.不存在的模块;  // 编译错误
   ```
   预期：编译时报错 "模块 '标准库.不存在的模块' 不存在"

4. **函数不存在**
   ```qi
   导入 标准库.加密;
   函数 入口() {
       变量 x = 加密.不存在的函数("test");  // 编译错误
   }
   ```
   预期：编译时报错 "模块 '加密' 中不存在函数 '不存在的函数'"

## 验证策略 (Validation)

### 单元测试
```rust
#[test]
fn test_module_registry() {
    let mut registry = ModuleRegistry::new();
    registry.register_stdlib_modules();

    // 测试模块存在性
    assert!(registry.has_module("加密"));
    assert!(registry.has_function("加密", "MD5哈希"));
}

#[test]
fn test_import_resolution() {
    // 测试导入解析
    // 测试命名空间调用
    // 测试编译时错误
}
```

### E2E 测试
```qi
// test_crypto_import.qi
导入 标准库.加密;

函数 入口() {
    变量 哈希: 字符串 = 加密.MD5哈希("测试");
    打印行(哈希);
}
```

运行：
```bash
cargo run -- run examples/module_import/test_crypto_import.qi
# 预期输出：正确的 MD5 哈希值
```

### 基准测试
- 编译时间不应增加超过 10%
- 生成的 LLVM IR 大小不应显著增加

### 回滚策略
- 环境变量 `QI_LEGACY_BUILTIN=true` 启用旧的内置函数行为
- 在 1 个版本周期内同时支持两种模式

## 风险与缓解 (Risks & Mitigations)

### 风险1：向后兼容性
现有代码使用 `MD5哈希()` 直接调用会失败

**缓解**：
- 提供清晰的错误信息指导用户添加导入
- 提供迁移工具自动添加导入语句
- 在文档中说明迁移步骤

### 风险2：性能影响
模块解析可能增加编译时间

**缓解**：
- 使用 HashMap 进行 O(1) 查找
- 编译时缓存模块信息
- 避免运行时开销

### 风险3：错误信息不清晰
用户可能不理解为什么需要导入

**缓解**：
- 中文错误信息
- 提供修复建议
- 在文档中详细说明

## 回滚计划

如果发现严重问题：
1. 设置 `QI_LEGACY_BUILTIN=true` 恢复旧行为
2. 发布 hotfix 版本
3. 在下一版本中修复问题

## 实施时间表

- Day 1-2: Step 1-2（模块注册系统 + IrBuilder 扩展）
- Day 3: Step 3-4（函数调用解析 + 加密模块重构）
- Day 4: Step 5-6（IO 模块重构 + 测试）
- Day 5: 文档更新 + 示例代码

## 成功标准

- ✅ 所有单元测试通过
- ✅ E2E 测试覆盖所有场景
- ✅ 编译时间增加 < 10%
- ✅ 文档完整且清晰
- ✅ 现有示例代码迁移完成
