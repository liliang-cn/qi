# Qi Runtime 集成文档

## 概述

本文档描述了如何在 `qi run` 命令中集成 Rust 编写的 Qi Runtime。

## 架构

### 组件层次

1. **Qi 编译器** (`src/cli/commands.rs`, `src/codegen/builder.rs`)

   - 将 Qi 源代码编译为 LLVM IR
   - 在生成的 LLVM IR 中声明 Runtime 函数
   - 在 `main` 函数中自动插入 Runtime 初始化和清理调用

2. **Qi Runtime** (`src/runtime/`)

   - `environment.rs` - Runtime 环境管理
   - `memory/` - 内存管理子系统
   - `io/` - I/O 操作（文件系统、网络、标准输入输出）
   - `stdlib/` - 标准库（字符串、数学、系统、转换、调试）
   - `error/` - 错误处理系统
   - `executor.rs` - C FFI 接口，供 LLVM 编译的代码调用

3. **Runtime 执行器** (`src/runtime/executor.rs`)
   - 提供 C ABI 兼容的函数接口
   - 管理全局 Runtime 实例
   - 提供内存分配、打印等基础功能

## 集成步骤

### 1. 修改 Cargo.toml

```toml
[lib]
name = "qi_compiler"
path = "src/lib.rs"
crate-type = ["rlib", "staticlib", "cdylib"]
```

这允许构建静态库（`.a`）和动态库（`.dylib`/`.so`），用于链接。

### 2. 创建 Runtime 执行器

在 `src/runtime/executor.rs` 中实现 C ABI 函数：

- `qi_runtime_initialize()` - 初始化 Runtime
- `qi_runtime_shutdown()` - 关闭 Runtime
- `qi_runtime_print_*()` - 打印函数
- `qi_runtime_alloc()` / `qi_runtime_dealloc()` - 内存管理

### 3. 修改代码生成器

在 `src/codegen/builder.rs` 中：

1. **添加 Runtime 函数声明**（`emit_llvm_ir` 方法）：

```rust
// Add Qi Runtime function declarations
ir.push_str("; Qi Runtime declarations\n");
ir.push_str("declare i32 @qi_runtime_initialize()\n");
ir.push_str("declare i32 @qi_runtime_shutdown()\n");
ir.push_str("declare i32 @qi_runtime_print(ptr)\n");
// ... 更多声明
```

2. **在 main 函数中插入 Runtime 初始化**：

```rust
if is_main {
    let init_result = self.generate_temp();
    self.add_instruction(IrInstruction::函数调用 {
        dest: Some(init_result),
        callee: "qi_runtime_initialize".to_string(),
        arguments: vec![],
    });
}
```

3. **使用 Runtime 打印函数替代 printf**：

```rust
AstNode::打印语句(print_stmt) => {
    // 根据类型选择 runtime 函数
    let runtime_func = match expr_type {
        "string" => "qi_runtime_println",
        "float" => "qi_runtime_println_float",
        _ => "qi_runtime_println_int",
    };

    let result = self.generate_temp();
    self.add_instruction(IrInstruction::函数调用 {
        dest: Some(result.clone()),
        callee: runtime_func.to_string(),
        arguments: vec![value],
    });
}
```

### 4. 修改 CLI 命令处理

在 `src/cli/commands.rs` 中：

1. **添加 Runtime 库构建支持**：

```rust
fn ensure_runtime_library_built(&self, config: &CompilerConfig) -> Result<(), CliError> {
    // 检查库是否存在
    // 如果不存在，运行 cargo build --release --lib
}
```

2. **修改链接步骤**：

```rust
// 链接时包含 Runtime 库
let output = Command::new("clang")
    .arg(&temp_executable.with_extension("o"))
    .arg(&runtime_lib_path)  // 添加 Runtime 库
    .arg("-o")
    .arg(&temp_executable)
    .output()
```

## 生成的 LLVM IR 示例

```llvm
; Generated by Qi Language Compiler
; Module ID = 'qi_program'

; Qi Runtime declarations
declare i32 @qi_runtime_initialize()
declare i32 @qi_runtime_shutdown()
declare i32 @qi_runtime_println_int(i64)
declare i32 @qi_runtime_println_float(double)
declare i32 @qi_runtime_println(ptr)

define i32 @main() {
entry:
    %t1 = call i32 @qi_runtime_initialize()
    %t2 = call i32 @qi_runtime_println_int(i64 42)
    %t3 = call i32 @qi_runtime_println_float(double 3.14)
    %t4 = call i32 @qi_runtime_println(ptr @.str3)
    %t5 = call i32 @qi_runtime_shutdown()
    ret i32 0
}
```

## 使用方法

### 编译并运行

```bash
# 构建 Runtime 库
cargo build --release --lib

# 构建编译器
cargo build --release --bin qi

# 运行 Qi 程序
./target/release/qi run examples/runtime_test.qi
```

### Verbose 模式

```bash
./target/release/qi --verbose run examples/runtime_test.qi
```

输出示例：

```
运行配置:
  目标平台: macOS
  优化级别: 基础优化
  源文件: "examples/runtime_test.qi"
  运行参数: []

正在编译: "examples/runtime_test.qi"
  编译完成，耗时: 6ms
  生成文件: "examples/runtime_test.ll"
正在编译 LLVM IR 到可执行文件...
  集成 Qi Runtime 支持...
  Runtime 库已存在: "/path/to/libqi_compiler.a"
  链接 Qi Runtime 库: "/path/to/libqi_compiler.a"
正在运行可执行文件...
42
3.14
你好，Qi Runtime！
```

## Runtime 功能

### 当前支持的功能

- ✅ Runtime 初始化和清理
- ✅ 打印整数 (`qi_runtime_println_int`)
- ✅ 打印浮点数 (`qi_runtime_println_float`)
- ✅ 打印字符串 (`qi_runtime_println`)
- ✅ 内存分配 (`qi_runtime_alloc`)
- ✅ 内存释放 (`qi_runtime_dealloc`)
- ✅ 错误处理（中文错误消息）
- ✅ 内存管理（引用计数 + GC）
- ✅ I/O 操作（文件系统、网络）
- ✅ 标准库模块

### 待实现功能

- ⏳ 程序执行接口 (`qi_runtime_execute`)
- ⏳ 异步运行时集成
- ⏳ 完整的垃圾回收策略
- ⏳ 更多标准库函数

## 技术细节

### Runtime 生命周期

1. **初始化**：在 `main` 函数开始时调用 `qi_runtime_initialize()`

   - 创建 RuntimeEnvironment 实例
   - 初始化内存管理器
   - 初始化文件系统和网络接口
   - 初始化标准库模块

2. **执行**：程序运行期间

   - 调用 Runtime 提供的各种函数
   - Runtime 跟踪内存使用、I/O 操作等指标

3. **清理**：在 `main` 函数返回前调用 `qi_runtime_shutdown()`
   - 触发垃圾回收
   - 清理网络连接
   - 关闭文件句柄
   - 释放 Runtime 资源

### 线程安全

- 全局 Runtime 实例使用 `Mutex` 保护
- 支持多线程访问（待完善）

### 错误处理

- Runtime 函数返回 `i32` 状态码
- 0 表示成功，-1 表示失败
- 错误消息输出到 stderr

## 文件结构

```
src/
├── runtime/
│   ├── mod.rs              # Runtime 模块定义和公共接口
│   ├── executor.rs         # C FFI 执行器（新增）
│   ├── environment.rs      # Runtime 环境管理
│   ├── memory/             # 内存管理
│   │   ├── mod.rs
│   │   ├── manager.rs      # 内存管理器
│   │   ├── allocator.rs    # 分配器
│   │   ├── gc.rs           # 垃圾回收
│   │   └── interface.rs    # 内存接口
│   ├── io/                 # I/O 操作
│   │   ├── mod.rs
│   │   ├── filesystem.rs   # 文件系统
│   │   ├── network.rs      # 网络
│   │   ├── stdio.rs        # 标准 I/O
│   │   └── interface.rs    # I/O 接口
│   ├── stdlib/             # 标准库
│   │   ├── mod.rs
│   │   ├── string.rs       # 字符串操作
│   │   ├── math.rs         # 数学函数
│   │   ├── system.rs       # 系统调用
│   │   ├── conversion.rs   # 类型转换
│   │   └── debug.rs        # 调试工具
│   └── error/              # 错误处理
│       ├── mod.rs
│       ├── handler.rs      # 错误处理器
│       └── chinese.rs      # 中文错误消息
├── codegen/
│   ├── mod.rs
│   ├── builder.rs          # IR 构建器（已修改）
│   └── llvm.rs
└── cli/
    ├── mod.rs
    └── commands.rs          # CLI 命令处理（已修改）
```

## 性能考虑

- Runtime 库编译为静态库（`.a`），在链接时嵌入
- Release 模式下启用 LTO 和优化
- 内存分配使用混合策略（引用计数 + 垃圾回收）
- I/O 操作使用缓冲

## 平台支持

当前支持：

- ✅ macOS (x86_64/ARM64)

计划支持：

- ⏳ Linux (x86_64/ARM64)
- ⏳ Windows (x86_64)
- ⏳ WebAssembly

## 调试和诊断

### 查看生成的 LLVM IR

```bash
./target/release/qi compile examples/runtime_test.qi
cat examples/runtime_test.ll
```

### Runtime 诊断

Runtime 提供了详细的调试信息和性能指标（需要启用 debug 模式）。

## 未来改进

1. **更完善的类型系统**：在代码生成时跟踪更精确的类型信息
2. **优化链接**：使用动态库减少可执行文件大小
3. **跨平台支持**：扩展到 Linux 和 Windows
4. **异步支持**：集成 Tokio 异步运行时
5. **插件系统**：允许动态加载 Runtime 扩展

## 总结

通过这次集成，Qi 编译器现在可以：

- 自动链接 Rust 编写的 Runtime
- 在编译的程序中使用 Runtime 提供的功能
- 提供更好的错误处理和中文支持
- 为将来的高级功能（异步、并发等）奠定基础

成功运行的示例证明了 Runtime 集成的正确性和可用性！
