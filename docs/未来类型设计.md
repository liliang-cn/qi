# 未来类型 (Future Type) 设计文档

**日期**: 2025-11-05
**版本**: v1.0
**状态**: 设计中

---

## 🎯 设计目标

为 Qi 语言添加真正的异步语义，通过 **未来** 类型区分异步函数和协程。

---

## 📝 核心概念

### 术语定义

- **未来** (`未来<T>`) = Future\<T\>
- **就绪** = 立即完成的未来
- **等待** = await，等待未来完成

---

## 🔧 语法设计

### 1. 未来类型声明

```qi
// 泛型未来类型
类型 未来<T>

// 使用示例
变量 结果: 未来<字符串>
变量 数值: 未来<整数>
```

### 2. 异步函数返回未来

```qi
// 异步函数声明
异步 函数 网络请求() : 未来<字符串> {
    // 模拟异步操作
    返回 未来::就绪("网络数据");
}

// 返回整数的异步函数
异步 函数 计算() : 未来<整数> {
    返回 未来::就绪(42);
}
```

### 3. 等待未来完成

```qi
函数 入口() {
    // 调用异步函数，得到未来
    变量 future = 网络请求();  // 类型: 未来<字符串>

    // 可以继续做其他事情
    打印("等待数据中...");

    // 等待未来完成
    变量 数据 = 等待 future;  // 阻塞直到完成
    打印(数据);  // 输出: 网络数据
}
```

### 4. 异步函数内部的等待

```qi
异步 函数 获取数据() : 未来<字符串> {
    变量 结果1 = 等待 网络请求();  // 等待第一个请求
    变量 结果2 = 等待 网络请求();  // 等待第二个请求
    返回 未来::就绪(结果1 + 结果2);
}
```

---

## 🏗️ 类型系统

### 未来类型结构

```qi
类型 未来<T> {
    // 内部状态
    状态: 未来状态,
    值: 可选<T>,
    错误: 可选<字符串>
}

枚举 未来状态 {
    等待中,    // Pending
    已完成,    // Completed
    已失败     // Failed
}
```

### 未来类型方法

```qi
实现 未来<T> {
    // 创建就绪的未来
    静态 函数 就绪(值: T) : 未来<T> {
        返回 未来 {
            状态: 未来状态::已完成,
            值: 某值(值),
            错误: 无值
        };
    }

    // 创建失败的未来
    静态 函数 失败(错误: 字符串) : 未来<T> {
        返回 未来 {
            状态: 未来状态::已失败,
            值: 无值,
            错误: 某值(错误)
        };
    }

    // 检查是否完成
    函数 已完成() : 布尔 {
        返回 本体.状态 == 未来状态::已完成;
    }

    // 获取值（阻塞）
    函数 获取() : T {
        当 !本体.已完成() {
            // 等待完成（调用运行时）
        }
        返回 本体.值.unwrap();
    }
}
```

---

## 🔄 编译器实现

### AST 节点

```rust
// src/parser/ast.rs

#[derive(Debug, Clone)]
pub enum Type {
    // 现有类型...
    整数,
    浮点数,
    字符串,
    布尔,

    // 新增: 未来类型
    未来(Box<Type>),  // Future<T>
}

#[derive(Debug, Clone)]
pub struct AsyncFunctionDeclaration {
    pub name: String,
    pub parameters: Vec<Parameter>,
    pub return_type: Option<Type>,  // 应该是 未来<T>
    pub body: Vec<AstNode>,
    pub visibility: Visibility,
}

#[derive(Debug, Clone)]
pub struct AwaitExpression {
    pub expression: Box<AstNode>,  // 要等待的未来
}
```

### 语法规则

```lalrpop
// src/parser/grammar.lalrpop

// 未来类型
FutureType: Type = {
    "未来" "<" <inner:Type> ">" => Type::未来(Box::new(inner)),
}

Type: Type = {
    "整数" => Type::整数,
    "字符串" => Type::字符串,
    FutureType,
    // ...
}

// 等待表达式
AwaitExpression: AstNode = {
    "等待" <expr:Precedence7> => AstNode::等待表达式(AwaitExpression {
        expression: Box::new(expr),
    }),
}
```

---

## 🔧 代码生成

### 未来类型的LLVM表示

```llvm
; 未来类型结构
%Future = type {
    i32,    ; 状态 (0=等待中, 1=已完成, 2=已失败)
    ptr,    ; 值指针
    ptr     ; 错误信息指针
}

; 创建就绪的未来
define ptr @qi_future_ready(ptr %value) {
    %future = alloca %Future
    %state_ptr = getelementptr %Future, ptr %future, i32 0, i32 0
    store i32 1, ptr %state_ptr  ; 已完成
    %value_ptr = getelementptr %Future, ptr %future, i32 0, i32 1
    store ptr %value, ptr %value_ptr
    ret ptr %future
}

; 等待未来完成
define ptr @qi_future_await(ptr %future) {
entry:
    br label %wait_loop

wait_loop:
    %state_ptr = getelementptr %Future, ptr %future, i32 0, i32 0
    %state = load i32, ptr %state_ptr
    %is_done = icmp eq i32 %state, 1
    br i1 %is_done, label %done, label %wait

wait:
    call void @qi_runtime_yield()  ; 让出CPU给其他协程
    br label %wait_loop

done:
    %value_ptr = getelementptr %Future, ptr %future, i32 0, i32 1
    %value = load ptr, ptr %value_ptr
    ret ptr %value
}
```

### 异步函数编译

```qi
异步 函数 示例() : 未来<整数> {
    返回 未来::就绪(42);
}
```

编译为:

```llvm
define ptr @示例() {
    %value = alloca i64
    store i64 42, ptr %value
    %future = call ptr @qi_future_ready(ptr %value)
    ret ptr %future
}
```

---

## 🏃 运行时支持

### Rust 运行时实现

```rust
// src/runtime/future.rs

use std::sync::{Arc, Mutex};

#[repr(C)]
pub struct Future<T> {
    state: Arc<Mutex<FutureState<T>>>,
}

enum FutureState<T> {
    Pending,
    Completed(T),
    Failed(String),
}

impl<T> Future<T> {
    pub fn ready(value: T) -> Self {
        Future {
            state: Arc::new(Mutex::new(FutureState::Completed(value))),
        }
    }

    pub fn failed(error: String) -> Self {
        Future {
            state: Arc::new(Mutex::new(FutureState::Failed(error))),
        }
    }

    pub fn await_value(&self) -> Result<T, String>
    where
        T: Clone,
    {
        loop {
            let state = self.state.lock().unwrap();
            match &*state {
                FutureState::Completed(value) => return Ok(value.clone()),
                FutureState::Failed(error) => return Err(error.clone()),
                FutureState::Pending => {
                    drop(state);
                    // 让出CPU给其他协程
                    std::thread::yield_now();
                }
            }
        }
    }
}

// FFI 接口
#[no_mangle]
pub extern "C" fn qi_future_ready_i64(value: i64) -> *mut Future<i64> {
    Box::into_raw(Box::new(Future::ready(value)))
}

#[no_mangle]
pub extern "C" fn qi_future_await_i64(future: *mut Future<i64>) -> i64 {
    unsafe {
        let future = &*future;
        future.await_value().unwrap_or(-1)
    }
}
```

---

## 📊 示例程序

### 示例 1: 基础用法

```qi
包 主程序;

异步 函数 网络请求(地址: 字符串) : 未来<字符串> {
    打印("开始请求: ");
    打印行(地址);
    // 模拟异步操作
    返回 未来::就绪("响应数据");
}

函数 入口() {
    打印行("=== 未来类型示例 ===");

    // 创建未来（不阻塞）
    变量 future1 = 网络请求("http://api.example.com");

    // 继续做其他事情
    打印行("主程序继续运行...");

    // 等待结果（阻塞）
    变量 数据 = 等待 future1;
    打印("收到数据: ");
    打印行(数据);
}
```

### 示例 2: 多个异步操作

```qi
包 主程序;

异步 函数 读取文件(路径: 字符串) : 未来<字符串> {
    返回 未来::就绪("文件内容");
}

异步 函数 处理数据() : 未来<整数> {
    // 并发启动多个异步操作
    变量 future1 = 读取文件("file1.txt");
    变量 future2 = 读取文件("file2.txt");

    // 等待第一个完成
    变量 内容1 = 等待 future1;
    打印行(内容1);

    // 等待第二个完成
    变量 内容2 = 等待 future2;
    打印行(内容2);

    返回 未来::就绪(100);
}

函数 入口() {
    变量 结果 = 等待 处理数据();
    打印("最终结果: ");
    打印行(结果);
}
```

### 示例 3: 与协程结合

```qi
包 主程序;

异步 函数 异步任务() : 未来<整数> {
    返回 未来::就绪(42);
}

函数 协程任务() {
    打印行("协程: 直接执行");
}

函数 入口() {
    // 异步函数 - 返回未来
    变量 future = 异步任务();
    打印行("异步函数已调用，返回未来");

    // 协程 - 直接启动
    启动 协程任务();
    打印行("协程已启动");

    // 等待异步结果
    变量 结果 = 等待 future;
    打印("异步结果: ");
    打印行(结果);
}
```

---

## 🔍 与协程的区别

| 特性 | 未来类型 (异步) | 协程 (启动) |
|------|----------------|-------------|
| **语法** | `异步 函数 f() : 未来<T>` | `函数 f()` + `启动 f()` |
| **返回值** | ✅ 返回 `未来<T>` | ❌ 不返回值 |
| **等待** | `等待 future` 阻塞获取结果 | 无等待机制 |
| **使用场景** | I/O、有返回值的异步操作 | 并发任务、后台处理 |
| **调用方式** | `变量 f = 异步函数()` | `启动 函数()` |
| **惰性执行** | ✅ 返回未来，等待时才执行 | ❌ 立即启动执行 |

---

## ✅ 实施步骤

### 阶段 1: 类型系统 (当前)
1. 在 AST 中添加 `Type::未来(Box<Type>)`
2. 更新 `AsyncFunctionDeclaration` 要求返回未来类型
3. 添加 `AwaitExpression` AST 节点

### 阶段 2: 语法解析
1. 添加未来类型解析规则
2. 修改异步函数解析，要求返回未来
3. 添加等待表达式解析

### 阶段 3: 类型检查
1. 验证异步函数返回未来类型
2. 验证等待表达式的参数是未来类型
3. 类型推导和错误报告

### 阶段 4: 代码生成
1. 生成未来结构的 LLVM IR
2. 实现未来创建函数
3. 实现等待逻辑

### 阶段 5: 运行时
1. 实现 `Future<T>` Rust 结构
2. 添加 FFI 函数
3. 集成协程调度器

### 阶段 6: 测试
1. 单元测试
2. 示例程序
3. 性能测试

---

## 📝 兼容性考虑

### 向后兼容

现有的异步函数代码:
```qi
异步 函数 旧函数() : 字符串 {  // 没有未来类型
    返回 "数据";
}
```

**处理方式**: 编译器自动包装为未来类型
```qi
// 编译器内部转换为:
异步 函数 旧函数() : 未来<字符串> {
    返回 未来::就绪("数据");
}
```

---

## 🎯 预期收益

1. **语义清晰**: 异步函数明确返回未来，协程不返回值
2. **惰性执行**: 未来可以延迟等待，提供更大灵活性
3. **类型安全**: 编译时检查异步操作类型
4. **易于理解**: 类似 Rust Future，概念成熟

---

**文档版本**: v1.0
**最后更新**: 2025-11-05
**作者**: Claude Code (AI Assistant)
